ネットワークワーキンググループT.ディアクス 



トランスポート層セキュリティ（TLS）プロトコルバージョン1.2 

このメモのステータス 

このドキュメントは、インターネットコミュニティ用のインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します. このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください. このメモの配布は無制限です. 

概要 

このドキュメントは、Transport Layer Security（TLS）プロトコルのバージョン1.2を規定しています. TLSプロトコルは、インターネット上の通信セキュリティを提供します. このプロトコルにより、クライアント/サーバーアプリケーションは、盗聴、改ざん、またはメッセージの偽造を防ぐように設計された方法で通信できます. 

1.はじめに 

TLSプロトコルの主な目的は、2つの通信アプリケーション間でプライバシーとデータの整合性を提供することです. このプロトコルは、TLSレコードプロトコルとTLSハンドシェイクプロトコルの2つの層で構成されています. TLSレコードプロトコルは、信頼できるトランスポートプロトコル（TCP [TCP]など）の上に階層化された最下位レベルです. TLSレコードプロトコルは、2つの基本的なプロパティを持つ接続セキュリティを提供します. 

-接続はプライベートです. 対称暗号化は、データ暗号化に使用されます（AES [AES]、RC4 [SCH]など）. この対称暗号化のキーは、接続ごとに一意に生成され、別のプロトコル（TLSハンドシェイクプロトコルなど）によってネゴシエートされた秘密に基づいています. レコードプロトコルは暗号化せずに使用することもできます. 

-接続は信頼できます. メッセージ転送には、キー付きMACを使用したメッセージ整合性チェックが含まれます. 安全なハッシュ関数（SHA-1など）がMAC計算に使用されます. レコードプロトコルはMACなしで動作できますが、通常はこのモードでのみ使用され、別のプロトコルがセキュリティパラメータをネゴシエートするためのトランスポートとしてレコードプロトコルを使用します. 

TLS Record Protocolは、さまざまな上位プロトコルのカプセル化に使用されます. このようなカプセル化されたプロトコルの1つであるTLSハンドシェイクプロトコルを使用すると、サーバーとクライアントは互いに認証し、アプリケーションプロトコルがデータの最初のバイトを送信または受信する前に暗号化アルゴリズムと暗号化キーをネゴシエートできます. TLSハンドシェイクプロトコルは、3つの基本的なプロパティを持つ接続セキュリティを提供します. 

-ピアのIDは、非対称または公開キー暗号化（例：RSA [RSA]、DSA [DSS]など）を使用して認証できます. この認証はオプションにすることができますが、通常は少なくとも1つのピアで必要です. 

-共有シークレットのネゴシエーションは安全です. ネゴシエートされたシークレットは盗聴者が利用できません. 認証された接続では、接続の真ん中に攻撃者が侵入してもシークレットを取得できません.  

-ネゴシエーションは信頼できる：攻撃者は、通信の当事者によって検出されることなく、ネゴシエーション通信を変更することはできません.  





TLSの利点の1つは、アプリケーションプロトコルに依存しないことです. 上位レベルのプロトコルは、TLSプロトコルの上に透過的に階層化できます. ただし、TLS標準は、プロトコルがTLSでセキュリティを追加する方法を指定していません. TLSハンドシェイクを開始する方法と交換される認証証明書を解釈する方法に関する決定は、TLSの上で実行されるプロトコルの設計者と実装者の判断に任されています. 

1.1. 要件の用語

このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は、 RFC 2119 [REQ]で説明されているように解釈されます.  

1.2. TLS 1.1との主な違い

このドキュメントはTLS 1.1 [TLS1.1]プロトコルの改訂版であり、特に暗号化アルゴリズムのネゴシエーションのために柔軟性が向上しています. 主な変更点は次のとおりです. 

-疑似ランダム関数（PRF）のMD5 / SHA-1の組み合わせは、暗号スイート指定のPRFに置き換えられました. このドキュメントのすべての暗号スイートはP_SHA256を使用します. 

-デジタル署名された要素のMD5 / SHA-1の組み合わせは、単一のハッシュに置き換えられました. 署名された要素には、使用されるハッシュアルゴリズムを明示的に指定するフィールドが含まれるようになりました. 

-受け入れるハッシュおよび署名アルゴリズムを指定するクライアントおよびサーバーの機能に対する実質的なクリーンアップ. これにより、以前のバージョンのTLSからの署名およびハッシュアルゴリズムに対する制約の一部も緩和されることに注意してください. 

-追加のデータモードでの認証済み暗号化のサポートの追加.  

-TLS拡張定義とAES暗号スイートは、外部[TLSEXT]と[TLSAES]から統合されました.  

-EncryptedPreMasterSecretバージョン番号のより厳密なチェック.  

-いくつかの要件を厳しくしました.  

-Verify_dataの長さが暗号スイートに依存するようになりました（デフォルトは12のままです）.  

-Bleichenbacher / Klima攻撃防御の説明をクリーンアップ.  

-多くの場合、アラートを送信する必要があります.  

-certificate_requestの後で、使用できる証明書がない場合、クライアントは空の証明書リストを送信する必要があります.  

-TLS_RSA_WITH_AES_128_CBC_SHAは、暗号スイートの実装に必須になりました.  

-HMAC-SHA256暗号スイートを追加しました.  

-IDEAおよびDES暗号スイートを削除しました. それらは現在非推奨であり、別のドキュメントに記載されます. 

-SSLv2下位互換性のあるHelloのサポートは、SHOULD NOTではなく送信することで、SHOULDではなくMAYになりました. サポートはおそらく将来的にはSHOULD NOTになるでしょう. 

-プレゼンテーション言語に制限付きの「フォールスルー」を追加して、複数のケースアームで同じエンコーディングを使用できるようにしました.  

-実装の落とし穴セクションを追加 

-通常の説明と編集作業.  

2.目標 

TLSプロトコルの目標は、優先度順に次のとおりです.  

1.暗号セキュリティ：TLSを使用して、2者間の安全な接続を確立する必要があります.  

2.相互運用性：独立したプログラマーは、お互いのコードを知らなくても、暗号パラメーターを正常に交換できるTLSを利用したアプリケーションを開発できる必要があります.  

3.拡張性：TLSは、必要に応じて新しい公開鍵とバルク暗号化方式を組み込むことができるフレームワークを提供しようとしています. これにより、2つのサブゴールも達成されます. 新しいプロトコルを作成する必要をなくし（そして新しい弱点が発生する危険を冒して）、新しいセキュリティライブラリ全体を実装する必要を回避します. 

4.相対的な効率：暗号化操作は、特に公開鍵操作でCPUを集中的に使用する傾向があります. このため、TLSプロトコルには、最初から確立する必要のある接続の数を減らすために、オプションのセッションキャッシュスキームが組み込まれています. さらに、ネットワークアクティビティを減らすように注意が払われています. 3.このドキュメントの目的

このドキュメントとTLSプロトコル自体は、Netscapeによって発行されたSSL 3.0プロトコル仕様に基づいています. このプロトコルとSSL 3.0の違いは劇的ではありませんが、TLSとSSL 3.0のさまざまなバージョンが相互運用できないほど重要です（ただし、各プロトコルには、実装が以前のバージョンに戻るメカニズムが組み込まれています）. このドキュメントは、主にプロトコルを実装する読者、およびプロトコルの暗号分析を行う読者を対象としています. 仕様はこれを念頭に置いて作成されており、これら2つのグループのニーズを反映することを目的としています. そのため、アルゴリズムに依存するデータ構造とルールの多くが（付録ではなく）テキストの本文に含まれ、それらに簡単にアクセスできます. 

このドキュメントは、サービス定義またはインターフェース定義の詳細を提供することを意図していませんが、堅固なセキュリティの維持に必要なポリシーの特定の領域をカバーしています.  

4.プレゼンテーション言語 

このドキュメントでは、外部表現でのデータのフォーマットを扱います. 次の非常に基本的で、ややカジュアルに定義されたプレゼンテーション構文が使用されます. 構文は、その構造のいくつかのソースから引き出されます. 構文はプログラミング言語「C」に似ており、構文も意図もXDR [XDR]に似ていますが、あまりにも多くの類似点を描くのは危険です. このプレゼンテーション言語の目的は、TLSのみを文書化することです. その特定の目標を超える一般的な用途はありません. 

4.1. 基本ブロックサイズ

すべてのデータ項目の表現は明示的に指定されています. 基本的なデータブロックサイズは1バイト（つまり、8ビット）です. 複数バイトのデータ項目は、左から右へ、上から下へのバイトの連結です. バイトストリームから、マルチバイトアイテム（この例では数値）は（C表記を使用して）次のように形成されます. 

      value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |
              ... | byte[n-1];

マルチバイト値のこのバイト順序は、一般的なネットワークバイト順序またはビッグエンディアン形式です.  

4.2. 雑多

コメントは「/ *」で始まり、「* /」で終わります.  

オプションのコンポーネントは、 "[[]]"二重括弧で囲むことによって示されます.  

未解釈のデータを含むシングルバイトエンティティは、不透明タイプです.  

4.3.  Vectors

ベクトル（一次元配列）は、同種のデータ要素のストリームです. ベクトルのサイズは、ドキュメント化時に指定するか、実行時まで指定しないでおくことができます. どちらの場合も、長さはベクトルの要素数ではなくバイト数を宣言します. T型の固定長ベクトルである新しい型T 'を指定する構文は、次のとおりです. 

T T '[n]; 

ここで、T 'はデータストリームでnバイトを占めます. nはTのサイズの倍数です. ベクトルの長さは、エンコードされたストリームには含まれません.  

次の例では、データはプロトコルが解釈しない3つの連続したバイトとして定義されていますが、データは3つの連続したデータであり、合計で9バイトを消費します.  

      opaque Datum[3];      /* three uninterpreted bytes */
      Datum Data[9];        /* 3 consecutive 3 byte vectors */

可変長ベクトルは、<floor..ceiling>という表記を使用して、有効な長さの部分範囲を包括的に指定することによって定義されます. これらがエンコードされると、実際の長さがバイトストリーム内のベクトルの内容に先行します. 長さは、ベクターの指定された最大（天井）長さを保持するために必要なバイト数を消費する数の形式になります. ゼロの実際の長さフィールドを持つ可変長ベクトルは、空のベクトルと呼ばれます. 

T T '<floor..ceiling>; 

次の例では、必須は300〜400バイトの不透明（OPAQUE）型を含む必要のあるベクトルです. 空にすることはできません. 実際の長さフィールドは、値400を表すのに十分なuint16という2バイトを消費します（セクション4.4を参照）. 一方、longerは最大800バイトのデータ、または400 uint16要素を表すことができ、空の場合があります. そのエンコードには、ベクターの前に付加される2バイトの実際の長さフィールドが含まれます. エンコードされたベクトルの長さは、単一の要素の長さの偶数倍でなければなりません（たとえば、uint16の17バイトのベクトルは不正です）. 

      opaque mandatory<300..400>;
            /* length field is 2 bytes, cannot be empty */
      uint16 longer<0..800>;
            /* zero to 400 16-bit unsigned integers */

4.4. 数字

基本的な数値データ型は、符号なしバイト（uint8）です. より大きな数値データ型はすべて、セクション4.1で説明されているように連結された固定長の一連のバイトから形成され、これも符号なしです. 次の数値タイプが事前定義されています. 

      uint8 uint16[2];
      uint8 uint24[3];
      uint8 uint32[4];
      uint8 uint64[8];

仕様のここや他の場所にあるすべての値は、ネットワークバイト（ビッグエンディアン）順で格納されます. 16進バイト01 02 03 04で表されるuint32は、10進値16909060と同等です. 

場合によっては（DHパラメーターなど）、整数を不透明なベクトルとして表す必要があることに注意してください. そのような場合、それらは符号なし整数として表されます（つまり、最上位ビットが設定されていても、先行ゼロオクテットは必要ありません）. 

4.5. 列挙型

enumと呼ばれる追加のスパースデータタイプを使用できます. enum型のフィールドは、定義で宣言された値のみを想定できます. 各定義は異なるタイプです. 同じタイプの列挙型のみを割り当てたり、比較したりできます. 次の例に示すように、列挙型のすべての要素に値を割り当てる必要があります. 列挙型の要素は順序付けされていないため、一意の値を任意の順序で割り当てることができます. 

enum {e1（v1）、e2（v2）、...、en（vn）[[、（n）]]} Te; 

列挙型は、バイトストリーム内で定義された最大の序数値と同じだけのスペースを占有します. 次の定義では、1バイトがColorタイプのフィールドを運ぶために使用されます. 

      enum { red(3), blue(5), white(7) } Color;

オプションで、関連するタグなしで値を指定して、余分な要素を定義せずに幅の定義を強制できます.  

次の例では、Tasteはデータストリームで2バイトを消費しますが、想定できる値は1、2、または4のみです.  

enum { sweet(1), sour(2), bitter(4), (32000) } Taste;

列挙型の要素の名前は、定義された型内でスコープされます. 最初の例では、列挙の2番目の要素への完全修飾参照はColor.blueになります. 割り当てのターゲットが明確に指定されている場合、そのような資格は必要ありません. 

      Color color = Color.blue;     /* overspecified, legal */
      Color color = blue;           /* correct, type implicit */

外部表現に変換されない列挙型の場合、数値情報は省略できます.  

      enum { low, medium, high } Amount;

4.6 構築された型

構造タイプは、便宜上、プリミティブタイプから構築できます. 各仕様は、新しい一意の型を宣言します. 定義の構文はCの構文によく似ています. 

      struct {
          T1 f1;
          T2 f2;
          ...
          Tn fn;
      } [[T]];

構造体内のフィールドは、列挙型で使用できる構文とよく似た構文で、型の名前を使用して修飾できます. たとえば、T.f2は前の宣言の2番目のフィールドを参照します. 構造定義を埋め込むことができます. 

4.6.1. バリアント

定義された構造には、環境内で利用可能ないくつかの知識に基づいたバリアントがある場合があります. セレクターは、構造が定義する可能なバリアントを定義する列挙型である必要があります. selectで宣言された列挙のすべての要素にケースアームが必要です. ケースアームのフォールスルーは限られています. 2つのケースアームがフィールドを挟まずに連続して続く場合、両方に同じフィールドが含まれます. したがって、以下の例では、「オレンジ」と「バナナ」の両方にV2が含まれています. これはTLS 1.2の新しい構文であることに注意してください. 

バリアント構造の本体には、参照用のラベルを付けることができます. 実行時にバリアントが選択されるメカニズムは、プレゼンテーション言語では規定されていません. 

struct {T1 f1; T2 f2; .... Tn fn; select（E）{case e1：Te1; ケースe2：Te2; ケースe3：ケースe4：Te3; ....ケースen：10; } [[F V]]; } [[Tv]];

例えば： 

enum {apple、orange、banana} VariantTag; 

struct {uint16番号; 不透明な文字列<0..10>; / *可変長* /} V1;

struct {uint32番号; 不透明な文字列[10]; / *固定長* /} V2;

struct {select（VariantTag）{/ *セレクターの値は暗黙的* / case apple：V1; / * VariantBody、tag = apple * /ケースオレンジ：ケースバナナ：V2; / * VariantBody、タグ=オレンジまたはバナナ* /} variant_body; / *バリアントのオプションのラベル* /} VariantRecord;





4.7. 暗号化属性

5つの暗号操作-デジタル署名、ストリーム暗号暗号化、ブロック暗号化暗号化、追加データ付き認証暗号化（AEAD）暗号化、および公開鍵暗号化-は、デジタル署名、ストリーム暗号化、ブロック暗号化、ead-暗号化に指定されています、公開鍵で暗号化されています. フィールドの暗号処理は、フィールドのタイプ指定の前に適切なキーワード指定を付加することによって指定されます. 暗号化キーは、現在のセッション状態によって暗示されます（セクション6.1を参照）. 

デジタル署名された要素は、DigitallySigned構造体としてエンコードされます.  

struct {SignatureAndHashAlgorithmアルゴリズム; 不透明な署名<0..2 ^ 16-1>; } DigitallySigned;

アルゴリズムフィールドは、使用されるアルゴリズムを指定します（このフィールドの定義については、セクション7.4.1.4.1を参照してください）. アルゴリズムフィールドの導入は、以前のバージョンからの変更であることに注意してください. 署名は、要素のコンテンツに対してこれらのアルゴリズムを使用するデジタル署名です. コンテンツ自体はネットワークに表示されず、単純に計算されます. 署名の長さは、署名アルゴリズムとキーによって指定されます. 

RSA署名では、不透明なベクターには、[PKCS1]で定義されているRSASSA-PKCS1-v1_5署名方式を使用して生成された署名が含まれています. [PKCS1]で説明されているように、DigestInfoはDERエンコード[X680] [X690]する必要があります. パラメータなしのハッシュアルゴリズム（SHA-1を含む）の場合、DigestInfo.AlgorithmIdentifier.parametersフィールドはNULLでなければならない（MUST）が、実装では、パラメータなしとNULLパラメータありの両方を受け入れる必要がある. 以前のバージョンのTLSでは、DigestInfoエンコーディングを含まない別のRSA署名方式を使用していたことに注意してください. 

DSAでは、SHA-1ハッシュの20バイトは、追加のハッシュなしでデジタル署名アルゴリズムを介して直接実行されます. これにより、rとsの2つの値が生成されます. DSA署名は、上記のように不透明なベクトルであり、その内容は次のDERエンコードです. 

Dss-Sig-Value :: = SEQUENCE {r INTEGER、s INTEGER} 



注：現在の用語では、DSAはデジタル署名アルゴリズムを指し、DSSはNIST標準を指します. 元のSSLおよびTLS仕様では、「DSS」が広く使用されていました. このドキュメントでは、「DSA」を使用してアルゴリズムを参照し、「DSS」を使用して標準を参照し、コードポイントの定義で「DSS」を使用して履歴の継続性を維持します. 

ストリーム暗号の暗号化では、平文は、暗号で保護されたキー付き擬似乱数ジェネレーターから生成された同じ量の出力と排他的論理和がとられます.  

ブロック暗号化暗号化では、平文のすべてのブロックが暗号文のブロックに暗号化されます. すべてのブロック暗号化暗号化はCBC（Cipher Block Chaining）モードで行われ、ブロック暗号化されるすべてのアイテムは、暗号化ブロック長の正確な倍数になります. 

AEAD暗号化では、平文は同時に暗号化され、整合性が保護されます. 入力は任意の長さにすることができ、整合性チェック値に対応するために、一般に、暗号化された出力は入力よりも大きくなります. 

公開鍵暗号化では、公開鍵アルゴリズムを使用して、一致する秘密鍵でのみ復号化できるようにデータを暗号化します. 公開鍵で暗号化された要素は、不透明なベクトル<0..2 ^ 16-1>としてエンコードされ、長さは暗号化アルゴリズムと鍵によって指定されます. 

RSA暗号化は、[PKCS1]で定義されているRSAES-PKCS1-v1_5暗号化スキームを使用して行われます.  

次の例では 

ストリーム暗号化された構造体{uint8 field1; uint8フィールド2; デジタル署名された不透明な{uint8 field3 <0..255>; uint8フィールド4; }; } ユーザータイプ;

内部構造体（field3およびfield4）の内容は、署名/ハッシュアルゴリズムの入力として使用され、構造全体がストリーム暗号で暗号化されます. この構造の長さ（バイト単位）は、field1とfield2の2バイト、署名とハッシュアルゴリズムの2バイト、署名の長さの2バイト、および署名の出力の長さに等しくなります. 



アルゴリズム. この構造をエンコードまたはデコードする前に、署名に使用されるアルゴリズムとキーがわかっているため、署名の長さがわかります. 

4.8. 定数

型付き定数は、目的の型のシンボルを宣言してそれに値を割り当てることにより、仕様の目的で定義できます.  

指定不足の型（不透明、可変長のベクトル、および不透明を含む構造体）には、値を割り当てることができません. 複数要素の構造体またはベクトルのフィールドは省略できません. 

例えば： 

struct {uint8 f1; uint8 f2; }例1;

例1 ex1 = {1、4}; / * f1 = 1、f2 = 4を割り当てます* /

5. HMACと疑似ランダム関数 

TLSレコードレイヤーは、キー付きのメッセージ認証コード（MAC）を使用してメッセージの整合性を保護します. このドキュメントで定義されている暗号スイートは、[HMAC]で説明されているHMACと呼ばれる構造を使用しており、ハッシュ関数に基づいています. 他の暗号スイートは、必要に応じて独自のMAC構造を定義してもよい（MAY）. 

さらに、キーの生成または検証のために、シークレットをデータのブロックに拡張するための構成が必要です. この疑似ランダム関数（PRF）は、秘密、シード、および識別ラベルを入力として受け取り、任意の長さの出力を生成します. 

このセクションでは、HMACに基づいて1つのPRFを定義します. SHA-256ハッシュ関数を使用したこのPRFは、このドキュメントおよびこのドキュメントの前に公開されたTLSドキュメントで定義されているすべての暗号スイートで、TLS 1.2のネゴシエート時に使用されます. 新しい暗号スイートは、PRFを明示的に指定する必要があり、一般に、SHA-256またはより強力な標準ハッシュ関数でTLS PRFを使用する必要があります（SHOULD）. 

最初に、単一のハッシュ関数を使用してシークレットを拡張し、任意の量の出力にシードするデータ拡張関数P_hash（secret、data）を定義します.  





P_hash（secret、seed）= HMAC_hash（secret、A（1）+ seed）+ HMAC_hash（secret、A（2）+ seed）+ HMAC_hash（secret、A（3）+ seed）+ ... 

+は連結を示します.  

A（）は次のように定義されます.  

A（0）=シードA（i）= HMAC_hash（secret、A（i-1）） 

P_hashは、必要な量のデータを生成するために必要な回数だけ繰り返すことができます. たとえば、80バイトのデータを作成するためにP_SHA256が使用されている場合、（A（3）を介して）3回繰り返す必要があり、96バイトの出力データが作成されます. 最後の反復の最後の16バイトは破棄され、80バイトの出力データが残ります. 

TLSのPRFは、P_hashをシークレットに次のように適用することによって作成されます.  

PRF（秘密、ラベル、シード）= P_ <ハッシュ>（秘密、ラベル+シード） 

ラベルはASCII文字列です. それは、長さバイトまたは末尾のヌル文字なしで与えられる正確な形式で含まれるべきです. たとえば、「slithy toves」というラベルは、次のバイトをハッシュすることによって処理されます. 

73 6C 69 74 68 79 20 74 6F 76 65 73 

6. TLSレコードプロトコル 

TLS Record Protocolは階層型プロトコルです. 各層で、メッセージには長さ、説明、および内容のフィールドが含まれる場合があります. Record Protocolは、送信されるメッセージを受け取り、データを管理可能なブロックに断片化し、オプションでデータを圧縮し、MACを適用し、暗号化して、結果を送信します. 受信したデータは、復号化、検証、解凍、再構成されてから、上位のクライアントに配信されます. 

このドキュメントでは、レコードプロトコルを使用する4つのプロトコル（ハンドシェイクプロトコル、アラートプロトコル、暗号仕様変更プロトコル、およびアプリケーションデータプロトコル）について説明します. TLSプロトコルの拡張を可能にするために、追加のレコードコンテンツタイプをレコードプロトコルでサポートできます. セクション12で説明されているように、新しいレコードコンテンツタイプの値は、TLSコンテンツタイプレジストリのIANAによって割り当てられます. 



実装は、何らかの拡張によって交渉されない限り、このドキュメントで定義されていないレコードタイプを送信してはなりません. TLS実装が予期しないレコードタイプを受信した場合は、予期しないメッセージアラートを送信する必要があります. 

TLSを介して使用するように設計されたプロトコルは、それに対する可能なすべての攻撃に対処するように注意深く設計する必要があります. 実際問題として、これは、プロトコル設計者がTLSが提供するセキュリティプロパティと提供しないセキュリティプロパティを認識している必要があり、TLSに安全に依存できないことを意味します. 

特に、レコードのタイプと長さは暗号化によって保護されないことに注意してください. この情報自体が機密情報である場合、アプリケーション設計者は、情報漏えいを最小限に抑えるための手順（パディング、トラフィックのカバー）を実行する必要がある場合があります. 

6.1. 接続状態

TLS接続状態は、TLSレコードプロトコルの動作環境です. 圧縮アルゴリズム、暗号化アルゴリズム、およびMACアルゴリズムを指定します. さらに、これらのアルゴリズムのパラメーターは既知です. 読み取りおよび書き込みの両方向の接続のMACキーとバルク暗号化キーです. 論理的には、未処理の接続状態が常に4つあります. 現在の読み取り状態と書き込み状態、および保留中の読み取り状態と書き込み状態です. すべてのレコードは、現在の読み取り状態と書き込み状態で処理されます. 保留状態のセキュリティパラメータはTLSハンドシェイクプロトコルによって設定でき、ChangeCipherSpecは保留状態のいずれかを選択的に最新にすることができます. この場合、適切な現在の状態が破棄され、保留状態に置き換えられます. その後、保留状態が空の状態に再初期化されます. セキュリティパラメータで初期化されていない状態を現在の状態にすることは不正です. 初期の現在の状態では、暗号化、圧縮、またはMACが使用されないことが常に指定されています. 

TLS接続の読み取りおよび書き込み状態のセキュリティパラメータは、次の値を指定することによって設定されます.  

connection end
このエンティティがこの接続で「クライアント」または「サーバー」と見なされるかどうか.  

PRF algorithm
マスターシークレットからキーを生成するために使用されるアルゴリズム（セクション5および6.3を参照）.  

bulk encryption algorithm
バルク暗号化に使用されるアルゴリズム. この仕様には、このアルゴリズムのキーサイズ、ブロック、ストリーム、またはAEAD暗号であるかどうか、暗号のブロックサイズ（該当する場合）、および明示的および暗黙的な初期化ベクトル（またはノンス）の長さが含まれます. 

MAC algorithm
メッセージ認証に使用されるアルゴリズム. この仕様には、MACアルゴリズムによって返される値のサイズが含まれます. 

compression algorithm
圧縮に使用されるアルゴリズム. この仕様には、アルゴリズムが圧縮を行うために必要なすべての情報を含める必要があります. 

master secret
接続の2つのピア間で共有される48バイトのシークレット.  

クライアントランダム
クライアントが提供する32バイトの値.  

server random
サーバーが提供する32バイトの値.        

      These parameters are defined in the presentation language as:

      enum { server, client } ConnectionEnd;

      enum { tls_prf_sha256 } PRFAlgorithm;

      enum { null, rc4, 3des, aes }
        BulkCipherAlgorithm;

      enum { stream, block, aead } CipherType;

      enum { null, hmac_md5, hmac_sha1, hmac_sha256,
           hmac_sha384, hmac_sha512} MACAlgorithm;

      enum { null(0), (255) } CompressionMethod;

/ * CompressionMethod、PRFAlgorithm、BulkCipherAlgorithm、およびMACAlgorithmで指定されたアルゴリズムを追加できます. * /


      struct {
          ConnectionEnd          entity;
          PRFAlgorithm           prf_algorithm;
          BulkCipherAlgorithm    bulk_cipher_algorithm;
          CipherType             cipher_type;
          uint8                  enc_key_length;
          uint8                  block_length;
          uint8                  fixed_iv_length;
          uint8                  record_iv_length;
          MACAlgorithm           mac_algorithm;
          uint8                  mac_length;
          uint8                  mac_key_length;
          CompressionMethod      compression_algorithm;
          opaque                 master_secret[48];
          opaque                 client_random[32];
          opaque                 server_random[32];
      } SecurityParameters;

レコードレイヤーは、セキュリティパラメーターを使用して、次の6つのアイテムを生成します（一部のアイテムはすべての暗号で必要とされないため、空です）.  

      client write MAC key
      server write MAC key
      client write encryption key
      server write encryption key
      client write IV
      server write IV

クライアントの書き込みパラメータは、レコードを受信して​​処理するときにサーバーによって使用され、その逆も同様です. セキュリティパラメータからこれらのアイテムを生成するために使用されるアルゴリズムについては、セクション6.3で説明します. 

セキュリティパラメータを設定してキーを生成したら、現在の状態にすることで接続状態をインスタンス化できます. これらの現在の状態は、処理されるレコードごとに更新する必要があります. 各接続状態には、次の要素が含まれています. 

圧縮状態圧縮アルゴリズムの現在の状態.  

暗号化状態暗号化アルゴリズムの現在の状態. これは、その接続用にスケジュールされたキーで構成されます. ストリーム暗号の場合、ストリームにデータの暗号化または復号化を継続させるために必要な状態情報も含まれます. 

MACキー上記で生成された、この接続のMACキー.  

シーケンス番号各接続状態にはシーケンス番号が含まれており、読み取り状態と書き込み状態で別々に保持されます. 接続状態がアクティブ状態になるときは常に、シーケンス番号をゼロに設定する必要があります. シーケンス番号のタイプはuint64で、2 ^ 64-1を超えることはできません. シーケンス番号は折り返されません. TLS実装でシーケンス番号をラップする必要がある場合は、代わりに再ネゴシエーションする必要があります. シーケンス番号は、各レコードの後に​​増加します. 具体的には、特定の接続状態で送信される最初のレコードは、シーケンス番号0を使用する必要があります. 

6.2. レコードレイヤー

TLSレコードレイヤーは、任意のサイズの空でないブロックで上位レイヤーから未解釈のデータを受け取ります.  

6.2.1. 断片化

レコード層は、情報ブロックをTLSPlaintextレコードにフラグメント化し、2 ^ 14バイト以下のチャンクでデータを伝送します. クライアントメッセージの境界はレコードレイヤーで保持されません（つまり、同じContentTypeの複数のクライアントメッセージが単一のTLSPlaintextレコードに合体されるか、単一のメッセージが複数のレコードにフラグメント化される場合があります）. 

      struct {
          uint8 major;
          uint8 minor;
      } ProtocolVersion;

      enum {
          change_cipher_spec(20), alert(21), handshake(22),
          application_data(23), (255)
      } ContentType;

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          opaque fragment[TLSPlaintext.length];
      } TLSPlaintext;

type囲まれたフラグメントの処理に使用される上位レベルのプロトコル.  

version使用されているプロトコルのバージョン. このドキュメントでは、バージョン{3、3}を使用するTLSバージョン1.2について説明します. バージョン値3.3はTLS 1.0の{3、1}の使用から派生した歴史的なものです. （付録A.1を参照してください. ）複数のバージョンのTLSをサポートするクライアントは、ServerHelloを受信する前にどのバージョンが使用されるかを認識していない場合があります. ClientHelloに使用する必要があるレコードレイヤーのバージョン番号については、付録Eを参照してください. 

length次のTLSPlaintext.fragmentの長さ（バイト単位）. 長さは2 ^ 14を超えてはなりません. 

フラグメントアプリケーションデータ. このデータは透過的であり、typeフィールドで指定された上位プロトコルで処理される独立したブロックとして扱われます. 

実装は、Handshake、Alert、またはChangeCipherSpecコンテンツタイプのゼロ長フラグメントを送信してはなりません（MUST NOT）. アプリケーションデータのゼロ長フラグメントは、トラフィック分析の対策として潜在的に役立つため、送信される場合があります. 

注：異なるTLSレコードレイヤーコンテンツタイプのデータはインターリーブされる場合があります. アプリケーションデータは一般に、他のコンテンツタイプよりも送信の優先順位が低くなります. ただし、レコードは、レコードレイヤーによって保護されているのと同じ順序でネットワークに配信する必要があります. 受信者は、接続の最初のハンドシェイクに続くハンドシェイク中に、インターリーブされたアプリケーションレイヤートラフィックを受信して​​処理する必要があります. 

6.2.2. レコードの圧縮と解凍

すべてのレコードは、現在のセッション状態で定義された圧縮アルゴリズムを使用して圧縮されます. 常にアクティブな圧縮アルゴリズムがあります. ただし、最初はCompressionMethod.nullとして定義されています. 圧縮アルゴリズムは、TLSPlaintext構造をTLSCompressed構造に変換します. 接続状態がアクティブになると、圧縮関数はデフォルトの状態情報で初期化されます. [RFC3749]は、TLSの圧縮アルゴリズムについて説明しています. 

圧縮はロスレスである必要があり、コンテンツの長さが1024バイトを超えないようにする必要があります. 解凍関数が2 ^ 14バイトを超える長さに解凍するTLSCompressed.fragmentを検出した場合、致命的な解凍失敗エラーを報告する必要があります. 

      struct {
          ContentType type;       /* same as TLSPlaintext.type */
          ProtocolVersion version;/* same as TLSPlaintext.version */
          uint16 length;
          opaque fragment[TLSCompressed.length];
      } TLSCompressed;

length次のTLSCompressed.fragmentの長さ（バイト単位）. 長さは2 ^ 14 + 1024を超えてはなりません. 

fragment TLSPlaintext.fragmentの圧縮形式.  

注：CompressionMethod.null操作はID操作です. フィールドは変更されません. 

実装上の注意：解凍関数は、メッセージが内部バッファオーバーフローを引き起こさないようにする責任があります.  

6.2.3. ペイロード保護の記録

暗号化およびMAC関数は、TLSCompressed構造をTLSCiphertextに変換します. 復号化関数はプロセスを逆にします. レコードのMACにはシーケンス番号も含まれているため、欠落、余分、または繰り返しのメッセージを検出できます. 

      struct {
          ContentType type;
          ProtocolVersion version;
          uint16 length;
          select (SecurityParameters.cipher_type) {
              case stream: GenericStreamCipher;
              case block:  GenericBlockCipher;
              case aead:   GenericAEADCipher;
          } fragment;
      } TLSCiphertext;

type typeフィールドはTLSCompressed.typeと同じです.  

version versionフィールドはTLSCompressed.versionと同じです.  

length次のTLSCiphertext.fragmentの長さ（バイト単位）. 長さは2 ^ 14 + 2048を超えてはなりません. fragment MACを使用したTLSCompressed.fragmentの暗号化された形式. 

6.2.3.1. ヌルまたは標準ストリーム暗号

ストリーム暗号（BulkCipherAlgorithm.nullを含む. 付録A.6を参照）は、TLSCompressed.fragment構造をストリームTLSCiphertext.fragment構造との間で変換します.  

      stream-ciphered struct {
          opaque content[TLSCompressed.length];
          opaque MAC[SecurityParameters.mac_length];
      } GenericStreamCipher;

MACは次のように生成されます.  

      MAC(MAC_write_key, seq_num +
                            TLSCompressed.type +
                            TLSCompressed.version +
                            TLSCompressed.length +
                            TLSCompressed.fragment);

「+」は連結を示します.  

seq_numこのレコードのシーケンス番号.  

MAC SecurityParameters.mac_algorithmで指定されたMACアルゴリズム.  

MACは暗号化の前に計算されることに注意してください. ストリーム暗号は、MACを含むブロック全体を暗号化します. 同期ベクトルを使用しないストリーム暗号（RC4など）の場合、1つのレコードの末尾からのストリーム暗号状態は、後続のパケットで単に使用されます. 暗号スイートがTLS_NULL_WITH_NULL_NULLの場合、暗号化はID操作で構成されます（つまり、データは暗号化されず、MACサイズはゼロであり、MACが使用されないことを意味します）. null暗号とストリーム暗号の両方で、TLSCiphertext.lengthはTLSCompressed.lengthにSecurityParameters.mac_lengthを加えたものです. 

6.2.3.2. CBCブロック暗号

ブロック暗号（3DESやAESなど）の場合、暗号化およびMAC関数は、TLSCompressed.fragment構造をブロックTLSCiphertext.fragment構造との間で変換します.  

      struct {
          opaque IV[SecurityParameters.record_iv_length];
          block-ciphered struct {
              opaque content[TLSCompressed.length];
              opaque MAC[SecurityParameters.mac_length];
              uint8 padding[GenericBlockCipher.padding_length];
              uint8 padding_length;
          };
      } GenericBlockCipher;

MACは、セクション6.2.3.1で説明されているように生成されます.  

IV初期化ベクトル（IV）はランダムに選択する必要があり（SHOULD）、予測不可能である必要があります. 1.1より前のバージョンのTLSでは、IVフィールドはなく、前のレコードの最後の暗号文ブロック（「CBC残差」）がIVとして使用されていました. これは、[CBCATT]で説明されている攻撃を防ぐために変更されました. ブロック暗号の場合、IVの長さはSecurityParameters.record_iv_lengthであり、SecurityParameters.block_sizeと同じです. 

平文の長さをブロック暗号のブロック長の整数倍にするために追加されるパディング. TLSCiphertext.lengthがブロック長の整数倍になる結果となる限り、パディングは255バイトまでの任意の長さでもかまいません. 交換されたメッセージの長さの分析に基づくプロトコルへの攻撃を妨げるには、必要以上に長い長さが望ましい場合があります. パディングデータベクトルの各uint8には、パディング長の値を入力する必要があります. 受信者はこのパディングをチェックする必要があり、バッドエラーを示すためにbad_record_macアラートを使用する必要があります. 

padding_lengthパディングの長さは、GenericBlockCipher構造の合計サイズが暗号のブロック長の倍数になるようにする必要があります. 有効な値の範囲は0〜255です. この長さは、padding_lengthフィールド自体を除いたpaddingフィールドの長さを指定します. 

暗号化されたデータの長さ（TLSCiphertext.length）は、SecurityParameters.block_length、TLSCompressed.length、SecurityParameters.mac_length、およびpadding_lengthの合計よりも1つ長くなります.  

例：ブロック長が8バイト、コンテンツ長（TLSCompressed.length）が61バイト、MAC長が20バイトの場合、パディング前の長さは82バイトです（これにはIVは含まれません. したがって、パディング長さモジュロ8は、合計長を8バイトの偶数倍にするために6に等しくなければなりません（ブロック長）. パディング長は、6、14、22などの254まで可能です. パディング長が必要最低限​​の6、パディングは6バイトで、それぞれに値6が含まれます. したがって、ブロック暗号化前のGenericBlockCipherの最後の8オクテットはxx 06 06 06 06 06 06となります. ここで、xxはマック. 

注：CBCモード（暗号ブロック連鎖）のブロック暗号では、暗号文を送信する前に、レコードの平文全体を知っておくことが重要です. それ以外の場合、攻撃者は[CBCATT]で説明されている攻撃を仕掛けることができます. 

実装メモ：Canvel et al. [CBCTIME]は、MACの計算に必要な時間に基づいて、CBCパディングに対するタイミング攻撃を実証しました. この攻撃を防ぐために、実装では、パディングが正しいかどうかに関係なく、レコード処理時間が基本的に同じであることを確認する必要があります. 一般的に、これを行う最良の方法は、パディングが正しくない場合でもMACを計算し、その後でのみパケットを拒否することです. たとえば、パッドが正しくないように見える場合、実装では長さゼロのパッドを想定し、MACを計算します. MACパフォーマンスはデータフラグメントのサイズにある程度依存するため、これにより小さなタイミングチャネルが残りますが、既存のMACのブロックサイズが大きく、MACのサイズが小さいため、悪用できるほど十分に大きいとは考えられていません. タイミング信号. 

6.2.3.3. AEAD暗号

AEAD [AEAD]暗号（[CCM]や[GCM]など）の場合、AEAD関数はTLSCompressed.fragment構造とAEAD TLSCiphertext.fragment構造との間で変換を行います.  

struct {opaque nonce_explicit [SecurityParameters.record_iv_length]; aead-ciphered struct {opaque content [TLSCompressed.length]; }; } GenericAEADCipher;

AEAD暗号は、[AEAD]のセクション2.1で説明されているように、認証チェックに含まれる単一のキー、ノンス、平文、および「追加データ」を入力として受け取ります. キーはclient_write_keyまたはserver_write_keyのいずれかです. MACキーは使用されません. 

各AEAD暗号スイートは、AEAD操作に提供されるナンスの構築方法と、GenericAEADCipher.nonce_explicit部分の長さを指定する必要があります. 多くの場合、[AEAD]のセクション3.2.1で説明されている部分的に暗黙的なナンス手法を使用するのが適切です. record_iv_lengthは、明示的な部分の長さです. この場合、暗黙の部分はclient_write_ivおよびserver_write_ivとしてkey_blockから派生する必要があり（セクション6.3で説明）、明示的な部分はGenericAEAEDCipher.nonce_explicitに含まれています. 

平文はTLSCompressed.fragmentです.  

追加の認証済みデータ（additional_dataと表記）は、次のように定義されます.  

additional_data = seq_num + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length; 

「+」は連結を示します.  

aead_outputは、AEAD暗号化操作によって出力された暗号文で構成されます. 長さは通常TLSCompressed.lengthよりも長くなりますが、量はAEAD暗号によって異なります. 暗号にはパディングが組み込まれている可能性があるため、オーバーヘッドの量はTLSCompressed.lengthの値によって異なります. 各AEAD暗号は、1024バイトを超える拡張を生成してはなりません（MUST NOT）. 象徴的に、

AEADEncrypted = AEAD-Encrypt（write_key、nonce、plaintext、additional_data） 

暗号化を解除して検証するために、暗号は入力として鍵、ノンス、「additional_data」、およびAEADEncrypted値を受け取ります. 出力は、平文または復号化が失敗したことを示すエラーのいずれかです. 個別の整合性チェックはありません. あれは：

TLSCompressed.fragment = AEAD-Decrypt（write_key、nonce、AEADEncrypted、additional_data） 

復号化が失敗した場合、致命的なbad_record_macアラートを生成する必要があります.  

6.3. キー計算

レコードプロトコルは、ハンドシェイクプロトコルによって提供されるセキュリティパラメータから現在の接続状態（付録A.6を参照）で必要なキーを生成するアルゴリズムを必要とします.  





マスターシークレットは一連の安全なバイトに展開され、クライアントの書き込みMACキー、サーバーの書き込みMACキー、クライアントの書き込み暗号化キー、サーバーの書き込み暗号化キーに分割されます. これらはそれぞれ、バイトシーケンスからこの順序で生成されます. 未使用の値は空です. 一部のAEAD暗号では、クライアント書き込みIVとサーバー書き込みIVがさらに必要になる場合があります（セクション6.2.3.3を参照）. 

キーとMACキーが生成されると、マスターシークレットがエントロピーソースとして使用されます.  

キーマテリアルを生成するには、 

key_block = PRF（SecurityParameters.master_secret、 "key Expansion"、SecurityParameters.server_random + SecurityParameters.client_random）; 

十分な出力が生成されるまで. 次に、key_blockは次のようにパーティション化されます. 

client_write_MAC_key [SecurityParameters.mac_key_length] server_write_MAC_key [SecurityParameters.mac_key_length] client_write_key [SecurityParameters.enc_key_length] server_write_key [SecurityParameters.enc_key_length] client_write_IV [SecurityParameters.fixed_iv_length] server_write_fix_iv [SecurityParameters.iv 

現在、client_write_IVとserver_write_IVは、[AEAD]のセクション3.2.1で説明されているように、暗黙のナンス手法に対してのみ生成されます.  

実装に関する注記：最も定義が必要な現在定義されている暗号スイートは、AES_256_CBC_SHA256です. 合計128バイトの鍵データのために、2 x 32バイトの鍵と2 x 32バイトのMAC鍵が必要です. 

7. TLSハンドシェイクプロトコル 

TLSには3つのサブプロトコルがあり、ピアがレコードレイヤーのセキュリティパラメーターについて合意し、自身を認証し、ネゴシエートされたセキュリティパラメーターをインスタンス化し、エラー状態を互いに報告することができます.  

ハンドシェイクプロトコルは、次の項目で構成されるセッションのネゴシエーションを担当します.  





セッション識別子アクティブまたは再開可能なセッション状態を識別するためにサーバーによって選択された任意のバイトシーケンス.  

ピア証明書X509v3 [PKIX]ピアの証明書. 状態のこの要素はnullである可能性があります. 

圧縮方法暗号化の前にデータを圧縮するために使用されるアルゴリズム.  

暗号仕様鍵情報、バルクデータ暗号化アルゴリズム（null、AESなど）、およびMACアルゴリズム（HMAC-SHA1など）の生成に使用される疑似ランダム関数（PRF）を指定します. また、mac_lengthなどの暗号属性も定義します. （正式な定義については、付録A.6を参照してください. ）

マスターシークレットクライアントとサーバー間で共有される48バイトのシークレット.  

is resumableセッションを使用して新しい接続を開始できるかどうかを示すフラグ.  

次に、これらのアイテムを使用して、アプリケーションデータを保護するときにレコードレイヤーで使用するセキュリティパラメーターを作成します. TLSハンドシェイクプロトコルの再開機能により、同じセッションを使用して多くの接続をインスタンス化できます. 

7.1. 暗号仕様プロトコルの変更

暗号仕様の変更プロトコルは、暗号化戦略の移行を知らせるために存在します. プロトコルは単一のメッセージで構成され、現在の（保留中ではない）接続状態で暗号化および圧縮されます. メッセージは、値1の1バイトで構成されます. 

struct {enum {change_cipher_spec（1）、（255）} type; } ChangeCipherSpec;

ChangeCipherSpecメッセージはクライアントとサーバーの両方から送信され、新しくネゴシエートされたCipherSpecとキーで後続のレコードが保護されることを受信側に通知します. このメッセージを受信すると、受信側はレコードレイヤーに読み取り保留状態を読み取り現在状態に直ちにコピーするように指示します. このメッセージを送信した直後に、送信者は、書き込み保留状態を書き込みアクティブ状態にするようにレコード層に指示する必要があります. （セクション6.1を参照してください. ）ChangeCipherSpecメッセージは、ハンドシェイク中にセキュリティパラメータが合意された後、確認済みのFinishedメッセージが送信される前に送信されます. 

注：データが接続上を流れている間に再ハンドシェイクが発生した場合、通信側は古いCipherSpecを使用してデータを送信し続ける場合があります. ただし、ChangeCipherSpecが送信されたら、新しいCipherSpecを使用する必要があります. ChangeCipherSpecを送信する最初の側は、反対側が新しいキー生成情報の計算を完了したことを知りません（たとえば、時間のかかる公開キー操作を実行する必要がある場合）. したがって、受信者がデータをバッファリングしなければならない小さな時間枠が存在する場合があります. 実際には、最新のマシンでは、この間隔はかなり短い可能性があります. 

7.2. アラートプロトコル

TLSレコードレイヤーでサポートされているコンテンツタイプの1つはアラートタイプです. アラートメッセージは、メッセージの重大度（警告または致命的）とアラートの説明を伝えます. 致命的なレベルのアラートメッセージは、接続を即座に終了させます. この場合、セッションに対応する他の接続は続行できますが、失敗したセッションが新しい接続の確立に使用されないように、セッション識別子を無効にする必要があります. 他のメッセージと同様に、現在の接続状態で指定されているように、アラートメッセージは暗号化および圧縮されます. 

列挙型{warning（1）、fatal（2）、（255）} AlertLevel; 

列挙型{close_notify（0）、unexpected_message（10）、bad_record_mac（20）、decryption_failed_RESERVED（21）、record_overflow（22）、decompression_failure（30）、handshake_failure（40）、no_certificate_RESERVED（41）、bad_certificate（42）、unsupported_certific ）、certificate_revoked（44）、certificate_expired（45）、certificate_unknown（46）、illegal_parameter（47）、unknown_ca（48）、access_denied（49）、decode_error（50）、decrypt_error（51）、export_restriction_RESERVED（60）、protocol_version（70 ）、不十分なセキュリティ（71）、内部エラー（80）、ユーザーキャンセル（90）、no_renegotiation（100）、サポートされていない拡張（110）、（255）} AlertDescription; 

struct {AlertLevel level; AlertDescriptionの説明. }アラート. 

7.2.1. 閉鎖アラート

クライアントとサーバーは、切り捨て攻撃を回避するために、接続が終了しているという知識を共有する必要があります. どちらの当事者も終了メッセージの交換を開始できます. 

close_notifyこのメッセージは、送信者がこの接続でこれ以上メッセージを送信しないことを受信者に通知します. TLS 1.1以降、接続を適切に閉じるのに失敗しても、セッションを再開する必要はなくなりました. これは、広範囲に及ぶ実装慣行に準拠するためのTLS 1.0からの変更点です. 

どちらの当事者も、close_notifyアラートを送信してクローズを開始できます. 閉鎖アラートの後に受信したデータは無視されます. 

他の致命的なアラートが送信されていない限り、各パーティは接続の書き込み側を閉じる前にclose_notifyアラートを送信する必要があります. 相手は、自分自身のclose_notifyアラートで応答し、保留中の書き込みを破棄して、接続をすぐに閉じる必要があります. クローズの開始側が、接続の読み取り側を閉じる前に、応答するclose_notifyアラートを待つ必要はありません. 

TLSを使用するアプリケーションプロトコルが、TLS接続が閉じられた後、基になるトランスポートを介してデータが伝送される可能性がある場合、TLS実装は、TLS接続が終了したことをアプリケーションレイヤーに示す前に、応答するclose_notifyアラートを受信する必要があります. アプリケーションプロトコルが追加のデータを転送せず、基になるトランスポート接続のみを閉じる場合、実装は、応答するclose_notifyを待たずにトランスポートを閉じることを選択できます（MAY）. 一部なし

TLSの使用プロファイルがデータトランスポートを管理する方法（接続のオープンまたはクローズを含む）を規定するために、この標準の解釈が必要です.  

注：接続を閉じると、トランスポートを破棄する前に、保留中のデータが確実に配信されると想定されています.  

7.2.2. エラーアラート

TLSハンドシェイクプロトコルでのエラー処理は非常に簡単です. エラーが検出されると、検出側は相手にメッセージを送信します. 致命的な警告メッセージを送信または受信すると、両方の当事者はすぐに接続を閉じます. サーバーとクライアントは、失敗した接続に関連付けられたセッション識別子、キー、およびシークレットをすべて忘れる必要があります. したがって、致命的なアラートで終了した接続は再開してはなりません. 

実装が致命的なアラートとして定義されている条件に遭遇した場合は常に、接続を閉じる前に適切なアラートを送信する必要があります. アラートレベルが明示的に指定されていないすべてのエラーについて、送信側は独自の裁量でこれを致命的なエラーとして扱うかどうかを決定できます（MAY）. 実装がアラートを送信することを選択したが、すぐに接続を閉じるつもりである場合は、そのアラートを致命的なアラートレベルで送信する必要があります. 

警告レベルのアラートが送受信された場合、通常、接続は正常に続行できます. 受信側が接続を続行しないことを決定した場合（たとえば、受け入れる意思がないというno_renegotiationアラートを受信した後）、致命的なアラートを送信して接続を終了する必要があります（SHOULD）. このため、一般に、送信側は受信側の動作を知ることができません. したがって、警告アラートは、送信側が接続を継続したい場合にはあまり有用ではないため、省略されることがあります. たとえば、ピアが期限切れの証明書を受け入れることを決定し（おそらくこれをユーザーに確認した後）、接続を続行したい場合、通常はcertificate_expiredアラートを送信しません. 

次のエラーアラートが定義されています.  

予期しないメッセージを受信しました. このアラートは常に致命的であり、適切な実装間の通信で決して監視されるべきではありません. 





bad_record_macこのアラートは、不正なMACでレコードを受信した場合に返されます. このアラートは、TLSCiphertextが無効な方法で復号化されたためにアラートが送信された場合にも返される必要があります. つまり、ブロック長の偶数倍でなかったか、チェックされたときのパディング値が正しくありませんでした. このメッセージは常に致命的であり、適切な実装間の通信で観察されることはありません（ネットワークでメッセージが破損した場合を除く）. 

decryption_failed_RESERVEDこのアラートは、TLSの以前のバージョンの一部で使用されており、CBCモード[CBCATT]に対する特定の攻撃を許可している可能性があります. 準拠した実装から送信してはなりません. 

record_overflow 2 ^ 14 + 2048バイトを超える長さのTLSCiphertextレコード、または2 ^ 14 + 1024バイトを超えるTLSCompressedレコードに復号化されたレコードを受信しました. このメッセージは常に致命的であり、適切な実装間の通信で観察されることはありません（ネットワークでメッセージが破損した場合を除く）. 

decompression_failure解凍関数が不適切な入力（たとえば、過度に長くなるデータ）を受け取りました. このメッセージは常に致命的であり、適切な実装間の通信で決して観察されるべきではありません. 

handshake_failure handshake_failureアラートメッセージの受信は、使用可能なオプションが指定されているため、送信者が許容可能なセキュリティパラメータのセットをネゴシエートできなかったことを示します. これは致命的なエラーです. 

no_certificate_RESERVEDこのアラートはSSLv3で使用されましたが、TLSのどのバージョンでも使用されていません. 準拠した実装から送信してはなりません. 

bad_certificate証明書が破損しているか、正しく検証されない署名が含まれているなど.  

unsupported_certificate証明書のタイプはサポートされていません.  

certificate_revoked証明書が署名者によって取り消されました.  



certificate_expired証明書の有効期限が切れているか、現在無効です.  

certificate_unknown証明書の処理中に他の（指定されていない）問題が発生し、受け入れられなくなりました.  

illegal_parameterハンドシェイクのフィールドが範囲外であるか、他のフィールドと矛盾しています. このメッセージは常に致命的です. 

unknown_ca有効な証明書チェーンまたは部分チェーンを受け取りましたが、CA証明書が見つからなかったか、既知の信頼できるCAと一致しなかったため、証明書は受け入れられませんでした. このメッセージは常に致命的です. 

access_denied有効な証明書が受信されましたが、アクセス制御が適用されたときに、送信者はネゴシエーションを続行しないことを決定しました. このメッセージは常に致命的です. 

decode_error一部のフィールドが指定された範囲外だったか、メッセージの長さが正しくなかったため、メッセージをデコードできませんでした. このメッセージは常に致命的であり、適切な実装間の通信で観察されることはありません（ネットワークでメッセージが破損した場合を除く）. 

decode_errorハンドシェイク暗号化操作が失敗しました. これには、署名を正しく検証できなかったり、Finishedメッセージを検証できなかったりすることが含まれます. このメッセージは常に致命的です. 

export_restriction_RESERVEDこのアラートは、TLSの以前のバージョンの一部で使用されていました. 準拠した実装から送信してはなりません. 

protocol_versionクライアントが交渉しようとしたプロトコルバージョンは認識されますが、サポートされていません. （たとえば、セキュリティ上の理由から、古いプロトコルバージョンは回避される場合があります. ）このメッセージは常に致命的です. 









サーバーがクライアントでサポートされているものよりも安全な暗号を必要とするため、ネゴシエーションが特に失敗した場合、handshake_failureの代わりに不十分なセキュリティが返されます. このメッセージは常に致命的です. 

internal_errorピアに関係のない内部エラーまたはプロトコルの正確性（メモリ割り当ての失敗など）により、続行できません. このメッセージは常に致命的です. 

user_canceledこのハンドシェイクは、プロトコル障害とは無関係の何らかの理由でキャンセルされています. ハンドシェイクの完了後にユーザーが操作をキャンセルした場合は、close_notifyを送信して接続を閉じるだけの方が適切です. このアラートの後には、close_notifyが続く必要があります. このメッセージは通常警告です. 

no_renegotiation最初のハンドシェイク後に、hello要求に応答してクライアントから送信されるか、クライアントhelloに応答してサーバーから送信されます. これらのいずれかは通常、再交渉につながります. それが適切でない場合、受信者はこのアラートで応答する必要があります. その時点で、元のリクエスターは接続を続行するかどうかを決定できます. これが適切なケースの1つは、サーバーが要求を満たすためにプロセスを生成した場合です. プロセスは起動時にセキュリティパラメータ（キーの長さ、認証など）を受け取り、その後のこれらのパラメータの変更を伝達することが困難になる場合があります. このメッセージは常に警告です. 

unsupported_extensionは、対応するclient helloに入れなかった拡張を含む拡張server helloを受信するクライアントによって送信されます. このメッセージは常に致命的です. 

セクション12で説明するように、新しいアラート値はIANAによって割り当てられます.  

7.3. ハンドシェイクプロトコルの概要

セッション状態の暗号化パラメーターは、TLSレコードレイヤー上で動作するTLSハンドシェイクプロトコルによって生成されます. TLSクライアントとサーバーが最初に通信を開始すると、プロトコルバージョンに同意し、暗号化アルゴリズムを選択し、必要に応じて相互に認証し、公開鍵暗号化技術を使用して共有シークレットを生成します. 



TLSハンドシェイクプロトコルには、次の手順が含まれます.  

-helloメッセージを交換してアルゴリズムについて合意し、ランダムな値を交換し、セッションの再開を確認します.  

-必要な暗号化パラメーターを交換して、クライアントとサーバーがプリマスターシークレットについて合意できるようにします.  

-証​​明書と暗号情報を交換して、クライアントとサーバーが自分自身を認証できるようにします.  

-プリマスターシークレットからマスターシークレットを生成し、ランダムな値を交換します.  

-レコードレイヤーにセキュリティパラメーターを提供します.  

-クライアントとサーバーが、ピアが同じセキュリティパラメータを計算したことと、攻撃者が改ざんせずにハンドシェイクが行われたことを確認できるようにします.  

TLSが常に2つのピア間の可能な限り最強の接続をネゴシエートするかどうかに、上位層が過度に依存してはならないことに注意してください. man-in-the-middle攻撃者が2つのエンティティをドロップして、サポートしている最も安全性の低い方法にしようとする方法はいくつかあります. プロトコルはこのリスクを最小限に抑えるように設計されていますが、利用可能な攻撃はまだあります. たとえば、攻撃者は安全なサービスが実行されているポートへのアクセスをブロックしたり、ピアに認証されていない接続をネゴシエートさせたりする可能性があります. 基本的なルールは、より高いレベルはセキュリティ要件が何であるかを認識している必要があり、必要以上に安全性の低いチャネルを介して情報を送信してはならないということです. TLSプロトコルは安全であり、どの暗号スイートも約束されたレベルのセキュリティを提供します. 

これらの目標は、次のように要約できるハンドシェイクプロトコルによって達成されます. クライアントはClientHelloメッセージを送信します. これに対してサーバーはServerHelloメッセージで応答する必要があります. そうしないと、致命的なエラーが発生して接続が失敗します. ClientHelloとServerHelloは、クライアントとサーバー間のセキュリティ強化機能を確立するために使用されます. ClientHelloとServerHelloは、プロトコルバージョン、セッションID、暗号スイート、および圧縮方法の属性を確立します. さらに、2つのランダムな値が生成および交換されます：ClientHello.randomとServerHello.random. 



実際の鍵交換では、最大4つのメッセージ（サーバー証明書、ServerKeyExchange、クライアント証明書、およびClientKeyExchange）を使用します. これらのメッセージのフォーマットを指定し、メッセージの使用を定義してクライアントとサーバーが共有シークレットに同意できるようにすることで、新しい鍵交換方法を作成できます. この秘密はかなり長いはずです. 現在定義されている鍵交換メソッドは、46バイト以上の範囲の秘密を交換します. 

helloメッセージに続いて、サーバーは、認証される場合、証明書メッセージで証明書を送信します. さらに、ServerKeyExchangeメッセージは、必要な場合（たとえば、サーバーに証明書がない場合、またはサーバーの証明書が署名専用の場合）に送信されることがあります. サーバーが認証されると、選択された暗号スイートに適切である場合、クライアントからの証明書を要求する可能性があります. 次に、サーバーはServerHelloDoneメッセージを送信し、ハンドシェイクのhello-messageフェーズが完了したことを示します. その後、サーバーはクライアントの応答を待ちます. サーバーがCertificateRequestメッセージを送信した場合、クライアントはCertificateメッセージを送信する必要があります. これでClientKeyExchangeメッセージが送信され、そのメッセージの内容は、ClientHelloとServerHelloの間で選択された公開鍵アルゴリズムに依存します. 

この時点で、クライアントによってChangeCipherSpecメッセージが送信され、クライアントは保留中の暗号仕様を現在の暗号仕様にコピーします. 次に、クライアントは、新しいアルゴリズム、キー、およびシークレットを使用して、直ちにFinishedメッセージを送信します. 応答として、サーバーは独自のChangeCipherSpecメッセージを送信し、保留を現在の暗号仕様に転送し、新しい暗号仕様の下で完了メッセージを送信します. この時点で、ハンドシェイクが完了し、クライアントとサーバーがアプリケーション層データの交換を開始します. （以下のフローチャートを参照してください. ）アプリケーションデータは、最初のハンドシェイクの完了前（TLS_NULL_WITH_NULL_NULL以外の暗号スイートが確立される前）に送信してはなりません（MUST NOT）. 

      Client                                               Server

      ClientHello                  -------->
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   <--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     -------->
                                               [ChangeCipherSpec]
                                   <--------             Finished
      Application Data             <------->     Application Data

             Figure 1.  Message flow for a full handshake

*常に送信されるとは限らないオプションまたは状況依存のメッセージを示します.  

注：パイプラインのストールを回避するために、ChangeCipherSpecは独立したTLSプロトコルコンテンツタイプであり、実際にはTLSハンドシェイクメッセージではありません.  

クライアントとサーバーが（新しいセキュリティパラメータをネゴシエートする代わりに）以前のセッションを再開するか、既存のセッションを複製することを決定した場合、メッセージフローは次のようになります.  

クライアントは、再開するセッションのセッションIDを使用してClientHelloを送信します. 次に、サーバーはセッションキャッシュをチェックして一致するかどうかを確認します. 一致が見つかり、サーバーが指定されたセッション状態で接続を再確立する用意がある場合、サーバーは同じセッションID値でServerHelloを送信します. この時点で、クライアントとサーバーの両方がChangeCipherSpecメッセージを送信し、終了メッセージに直接進む必要があります. 再確立が完了すると、クライアントとサーバーはアプリケーション層データの交換を開始する場合があります. （以下のフローチャートを参照してください. ）セッションIDの一致が見つからない場合、サーバーは新しいセッションIDを生成し、TLSクライアントとサーバーは完全なハンドシェイクを実行します. 

      Client                                                Server

      ClientHello                   -------->
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    <--------             Finished
      [ChangeCipherSpec]
      Finished                      -------->
      Application Data              <------->     Application Data


図2.省略されたハンドシェイクのメッセージフロー 

各メッセージの内容と重要性については、次のセクションで詳しく説明します.  

7.4. ハンドシェイクプロトコル

TLSハンドシェイクプロトコルは、TLSレコードプロトコルの定義済みの高レベルクライアントの1つです. このプロトコルは、セッションの安全な属性をネゴシエートするために使用されます. ハンドシェイクメッセージはTLSレコードレイヤーに提供され、1つ以上のTLSPlaintext構造内にカプセル化されます. これらの構造は、現在アクティブなセッション状態で指定されたとおりに処理および送信されます. 

      enum {
          hello_request(0), client_hello(1), server_hello(2),
          certificate(11), server_key_exchange (12),
          certificate_request(13), server_hello_done(14),
          certificate_verify(15), client_key_exchange(16),
          finished(20), (255)
      } HandshakeType;

      struct {
          HandshakeType msg_type;    /* handshake type */
          uint24 length;             /* bytes in message */
          select (HandshakeType) {
              case hello_request:       HelloRequest;
              case client_hello:        ClientHello;
              case server_hello:        ServerHello;
              case certificate:         Certificate;
              case server_key_exchange: ServerKeyExchange;
              case certificate_request: CertificateRequest;
              case server_hello_done:   ServerHelloDone;
              case certificate_verify:  CertificateVerify;
              case client_key_exchange: ClientKeyExchange;
              case finished:            Finished;
          } body;
      } Handshake;

以下に、ハンドシェイクプロトコルメッセージを送信する必要がある順序で示します. 予期しない順序でハンドシェイクメッセージを送信すると、致命的なエラーが発生します. ただし、不要なハンドシェイクメッセージは省略できます. 順序付けの1つの例外に注意してください. 証明書メッセージはハンドシェイクで2回使用されますが（サーバーからクライアント、次にクライアントからサーバーへ）、最初の位置でのみ説明されています. これらの順序付け規則に拘束されない1つのメッセージは、HelloRequestメッセージです. これはいつでも送信できますが、ハンドシェイクの途中で到着した場合、クライアントによって無視される必要があります（SHOULD）. 

セクション12で説明するように、新しいハンドシェイクメッセージタイプはIANAによって割り当てられます.  

7.4.1.  Hello Messages

helloフェーズメッセージは、クライアントとサーバー間でセキュリティ強化機能を交換するために使用されます. 新しいセッションが始まると、record layerの接続状態の暗号化、ハッシュ、および圧縮アルゴリズムはnullに初期化されます. 現在の接続状態は再ネゴシエーションメッセージに使用されます. 

7.4.1.1.  Hello Request

このメッセージが送信されるタイミング： 

HelloRequestメッセージはいつでもサーバーから送信できます.  

このメッセージの意味： 

HelloRequestは、クライアントがネゴシエーションプロセスを新たに開始する必要があるという単純な通知です. 応答として、クライアントは都合のよいときにClientHelloメッセージを送信する必要があります. このメッセージは、どちらの側がクライアントまたはサーバーであるかを確立するためのものではなく、単に新しいネゴシエーションを開始するためのものです. サーバーは、クライアントの初期接続時にすぐにHelloRequestを送信しないでください. そのときにClientHelloを送信するのはクライアントの仕事です. 
クライアントが現在セッションをネゴシエートしている場合、
このメッセージはクライアントによって無視されます. このメッセージは、セッションを再ネゴシエートしたくない場合はクライアントによって無視される場合があります. または、クライアントが希望する場合は、no_renegotiationアラートで応答できます. ハンドシェイクメッセージは、アプリケーションデータよりも送信の優先度を高くすることを目的としているため、クライアントから受信するレコードが数個以下になる前にネゴシエーションが開始されることが予想されます. サーバーがHelloRequestを送信してもClientHelloを受信しない場合、致命的なアラートで接続を閉じることがあります. HelloRequestを送信した後、サーバーは次のハンドシェイクネゴシエーションが完了するまで要求を繰り返さないでください（SHOULD NOT）. 

このメッセージの構造： 

struct {} HelloRequest; 

このメッセージは、ハンドシェイク全体で維持され、終了メッセージと証明書検証メッセージで使用されるメッセージハッシュに含めることはできません.  

7.4.1.2.  Client Hello

このメッセージが送信されるタイミング： 

クライアントが最初にサーバーに接続するとき、最初のメッセージとしてClientHelloを送信する必要があります. クライアントは、既存の接続でセキュリティパラメータを再ネゴシエートするために、HelloRequestに応答して、または独自のイニシアチブでClientHelloを送信することもできます. 

このメッセージの構造： 

ClientHelloメッセージには、後でプロトコルで使用されるランダムな構造が含まれます.  

         struct {
             uint32 gmt_unix_time;
             opaque random_bytes[28];
         } Random;

gmt_unix_time
送信者の内部クロックによる、標準のUNIX 32ビット形式（1970年1月1日から始まる午前0時からの秒数、UTC、うるう秒は無視）の現在の日時. 基本的なTLSプロトコルでクロックを正しく設定する必要はありません. より高いレベルまたはアプリケーションプロトコルは、追加の要件を定義する場合があります. 歴史的な理由により、データ要素の名前は、現在の世界的なタイムベースであるUTCの前身であるGMTを使用して付けられていることに注意してください. 

random_bytes
安全な乱数ジェネレータによって生成された28バイト.  

ClientHelloメッセージには、可変長のセッション識別子が含まれます. 空でない場合、この値は、同じクライアントと、クライアントが再利用したいセキュリティパラメータを持つサーバーとの間のセッションを識別します. セッション識別子は、以前の接続、この接続、または現在アクティブな別の接続からのものである場合があります. 2番目のオプションは、クライアントが接続のランダムな構造と派生値のみを更新する場合に便利です. 3番目のオプションを使用すると、完全なハンドシェイクプロトコルを繰り返さなくても、複数の独立した安全な接続を確立できます. これらの独立した接続は、順次または同時に発生します. セッションIDは、ネゴシエートするハンドシェイクが完了メッセージの交換で完了したときに有効になり、エージングまたはセッションに関連付けられた接続で致命的なエラーが発生したために削除されるまで保持されます. SessionIDの実際の内容はサーバーによって定義されます. 

opaque SessionID<0..32>;

警告：SessionIDは暗号化または即時MAC保護なしで送信されるため、サーバーはセッション識別子に機密情報を配置したり、偽のセッション識別子の内容がセキュリティ違反を引き起こしてはなりません. （SessionIDを含む、全体としてのハンドシェイクのコンテンツは、ハンドシェイクの最後に交換されるFinishedメッセージによって保護されることに注意してください. ）

ClientHelloメッセージでクライアントからサーバーに渡される暗号スイートリストには、クライアントの優先順（優先順が最初）でクライアントがサポートする暗号化アルゴリズムの組み合わせが含まれています. 各暗号スイートは、鍵交換アルゴリズム、バルク暗号化アルゴリズム（秘密鍵の長さを含む）、MACアルゴリズム、およびPRFを定義します. サーバーは暗号スイートを選択するか、受け入れ可能な選択肢が提示されない場合は、ハンドシェイク失敗アラートを返し、接続を閉じます. リストにサーバーが認識、サポート、または使用を希望しない暗号スイートが含まれている場合、サーバーはそれらの暗号スイートを無視し、残りの暗号スイートを通常どおり処理する必要があります. 

uint8 CipherSuite [2]; / *暗号スイートセレクタ* /

ClientHelloには、クライアントの優先順位に従って並べられた、クライアントでサポートされている圧縮アルゴリズムのリストが含まれています.  

      enum { null(0), (255) } CompressionMethod;

      struct {
          ProtocolVersion client_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suites<2..2^16-2>;
          CompressionMethod compression_methods<1..2^8-1>;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ClientHello;

TLSでは、拡張機能が拡張機能ブロックのcompression_methodsフィールドに続くことができます. 拡張の存在は、ClientHelloの最後にあるcompression_methodsに続くバイトがあるかどうかを判断することで検出できます. このオプションのデータを検出する方法は、可変長フィールドを持つ通常のTLS方法とは異なりますが、拡張が定義される前のTLSとの互換性のために使用されます. 

client_version
クライアントがこのセッション中に通信したいTLSプロトコルのバージョン. これは、クライアントがサポートする最新の（最も価値の高い）バージョンである必要があります（SHOULD）. このバージョンの仕様では、バージョンは3.3になります（下位互換性の詳細については、付録Eを参照してください）. 

random
クライアントが生成したランダムな構造.  

session_id
クライアントがこの接続に使用するセッションのID. 使用可能なsession_idがない場合、またはクライアントが新しいセキュリティパラメータを生成する場合は、このフィールドは空です. 

cipher_suites
これは、クライアントがサポートする暗号化オプションのリストで、クライアントの最初の優先順位が最初です. session_idフィールドが空でない場合（セッション再開要求を意味します）、このベクターには少なくともそのセッションからのcipher_suiteが含まれている必要があります. 値は付録A.5で定義されています. 

compression_methods
これは、クライアント設定でソートされた、クライアントでサポートされている圧縮方式のリストです. session_idフィールドが空でない場合（セッション再開要求を意味します）、そのセッションからのcompression_methodを含める必要があります. このベクターはCompressionMethod.nullを含んでいる必要があり、すべての実装がサポートする必要があります. したがって、クライアントとサーバーは常に圧縮方法について合意することができます. 

extensions
クライアントは、extensionsフィールドでデータを送信することにより、サーバーに拡張機能をリクエストできます. 実際の「拡張子」フォーマットは、セクション7.4.1.4で定義されています. 

クライアントが拡張機能を使用して追加の機能を要求し、この機能がサーバーによって提供されていない場合、クライアントはハンドシェイクを中止してもよい（MAY）. サーバーは拡張フィールドがある場合とない場合の両方でClientHelloメッセージを受け入れる必要があり、（他のすべてのメッセージと同様に）メッセージ内のデータ量がこれらの形式の1つと正確に一致することを確認する必要があります. そうでない場合は、致命的な「decode_error」アラートを送信する必要があります. 

ClientHelloメッセージを送信した後、クライアントはServerHelloメッセージを待ちます. HelloRequestを除き、サーバーから返されたハンドシェイクメッセージはすべて致命的なエラーとして扱われます. 

7.4.1.3.  Server Hello

このメッセージが送信されるタイミング： 

サーバーは、許容可能なアルゴリズムのセットを見つけることができたときに、ClientHelloメッセージへの応答としてこのメ​​ッセージを送信します. そのような一致が見つからない場合は、ハンドシェイク失敗アラートで応答します. 

このメッセージの構造： 

      struct {
          ProtocolVersion server_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suite;
          CompressionMethod compression_method;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ServerHello;


拡張機能の存在は、ServerHelloの末尾にあるcompression_methodフィールドに続くバイトがあるかどうかを判断することで検出できます.  

server_version
このフィールドには、クライアントがクライアントhelloで提案した値の低い方と、サーバーがサポートする最も高い方が含まれます. このバージョンの仕様では、バージョンは3.3です. （下位互換性の詳細については、付録Eを参照してください. ）

random
この構造はサーバーによって生成され、ClientHello.randomから独立して生成される必要があります.  

session_id
これは、この接続に対応するセッションのIDです. ClientHello.session_idが空でなかった場合、サーバーはそのセッションキャッシュで一致を探します. 一致が見つかり、サーバーが指定されたセッション状態を使用して新しい接続を確立する用意がある場合、サーバーはクライアントから提供されたものと同じ値で応答します. これはセッションが再開されたことを示し、当事者が終了メッセージに直接進む必要があることを示します. それ以外の場合、このフィールドには、新しいセッションを識別する別の値が含まれます. サーバーは空のsession_idを返し、セッションがキャッシュされないため再開できないことを示します. セッションを再開する場合は、最初にネゴシエートしたときと同じ暗号スイートを使用して再開する必要があります. 以前にsession_idを提供していた場合でも、サーバーがセッションを再開する必要はないことに注意してください. クライアントは、すべてのハンドシェイク中に、完全なネゴシエーション（新しい暗号スイートのネゴシエーションを含む）を実行できるように準備する必要があります. 

cipher_suite 
ClientHello.cipher_suitesのリストからサーバーによって選択された単一の暗号スイート. 再開されたセッションの場合、このフィールドは、再開されているセッションの状態からの値です. 

compression_method
サーバーがClientHello.compression_methodsのリストから選択した単一の圧縮アルゴリズム. 再開されたセッションの場合、このフィールドは再開されたセッション状態からの値です. 

extensions
拡張機能のリスト. クライアントが提供する拡張機能のみがサーバーのリストに表示されることに注意してください. 



7.4.1.4.  Hello Extensions

拡張形式は次のとおりです.  

struct {ExtensionType extension_type; 不透明なextension_data <0..2 ^ 16-1>; }拡張. 

列挙型{signature_algorithms（13）、（65535）} ExtensionType; 

ここに： 

-「extension_type」は、特定の拡張タイプを識別します.  

-「extension_data」には、特定の拡張タイプに固有の情報が含まれています.  

拡張機能の最初のセットは、関連ドキュメント[TLSEXT]で定義されています. 拡張タイプのリストは、セクション12で説明されているように、IANAによって維持されます. 

同じ拡張タイプが対応するClientHelloに現れない限り、拡張タイプはServerHelloに現れてはいけません（MUST NOT）. クライアントが、関連付けられたClientHelloで要求しなかった拡張タイプをServerHelloで受信した場合、unsupported_extensionの致命的なアラートでハンドシェイクを中止する必要があります. 

それにもかかわらず、「サーバー指向」の拡張機能は、このフレームワーク内で将来提供される可能性があります. そのような拡張（たとえば、タイプx）は、クライアントがまず拡張タイプをサポートすることを示すために、空のextension_dataを持つClientHelloでタイプxの拡張を送信する必要があります. この場合、クライアントは拡張タイプを理解する機能を提供しており、サーバーはクライアントをその提案に引き継いでいます. 

ClientHelloまたはServerHelloメッセージに異なるタイプの複数の拡張が存在する場合、拡張は任意の順序で表示される場合があります. 同じタイプの複数の拡張があってはなりません. 

最後に、新しいセッションを開始するときとセッションの再開を要求するときの両方で拡張機能を送信できることに注意してください. 実際、セッションの再開を要求するクライアントは、通常、サーバーがこの要求を受け入れるかどうかを知らないため、再開を試みなかった場合と同じ拡張子を送信する必要があります（SHOULD）. 一般に、各拡張タイプの仕様は、完全なハンドシェイクとセッション再開の両方の間の拡張の効果を記述する必要があります. 最新のTLS拡張は、セッションが開始されたときにのみ関連します. 古いセッションが再開されると、サーバーはこれらの拡張をClient Helloで処理せず、Server Helloに含めません. ただし、一部の拡張機能では、セッション再開時に異なる動作を指定する場合があります. 

新しいプロトコルと既存の機能の間でこのプロトコルで発生する可能性のある微妙な（それほど微妙ではない）相互作用があり、全体的なセキュリティが大幅に低下する可能性があります. 新しい拡張機能を設計するときは、次の考慮事項を考慮する必要があります. 

-サーバーが拡張機能に同意しない場合や、特定の機能のサポートを拒否する場合があります. 一般的に、前者にはエラーアラートを、後者にはサーバーエクステンション応答のフィールドを使用する必要があります. 

-拡張機能は、ハンドシェイクメッセージの操作によって特定の機能の使用（または非使用）を強制する攻撃を防ぐために、可能な限り設計する必要があります. 機能がセキュリティ上の問題を引き起こすと考えられているかどうかにかかわらず、この原則に従う必要があります. 

多くの場合、拡張フィールドがFinishedメッセージハッシュへの入力に含まれているという事実で十分ですが、拡張機能がハンドシェイクフェーズで送信されるメッセージの意味を変更する場合は、細心の注意が必要です. 設計者と実装者は、ハンドシェイクが認証されるまで、アクティブな攻撃者がメッセージを変更し、拡張機能を挿入、削除、または置き換えることができるという事実に注意する必要があります. 

-TLSの設計の主要な側面を変更するために拡張を使用することは技術的に可能です. たとえば、暗号スイートのネゴシエーションの設計. これは推奨されません. 新しいバージョンのTLSを定義する方が適切です. 特に、TLSハンドシェイクアルゴリズムにはバージョン番号に基づくバージョンロールバック攻撃に対する特定の保護機能があり、主要な設計変更ではバージョンロールバックの可能性を考慮する必要があります. 

7.4.1.4.1.  Signature Algorithms

クライアントは、「signature_algorithms」拡張を使用して、デジタル署名で使用できる署名/ハッシュアルゴリズムのペアをサーバーに示します. この拡張の「extension_data」フィールドには、「supported_signature_algorithms」値が含まれています. 

      enum {
          none(0), md5(1), sha1(2), sha224(3), sha256(4), sha384(5),
          sha512(6), (255)
      } HashAlgorithm;

      enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }
        SignatureAlgorithm;

      struct {
            HashAlgorithm hash;
            SignatureAlgorithm signature;
      } SignatureAndHashAlgorithm;

      SignatureAndHashAlgorithm
        supported_signature_algorithms<2..2^16-2>;

各SignatureAndHashAlgorithm値は、クライアントが確認する用意のある1つのハッシュ/署名ペアをリストします. 値は優先度の高い順に示されています. 

注：すべての署名アルゴリズムとハッシュアルゴリズムが実装で受け入れられるとは限らないため（たとえば、SHA-1を使用したDSAですが、SHA-256では使用できません）、ここでのアルゴリズムはペアでリストされます.  

hashこのフィールドは、使用可能なハッシュアルゴリズムを示します. 値は、ハッシュされていないデータ、MD5 [MD5]、SHA-1、SHA-224、SHA-256、SHA-384、SHA-512 [SHS]のサポートをそれぞれ示します. 「なし」の値は、署名前にハッシュを必要としない署名アルゴリズムの場合に、将来の拡張性のために提供されています. 

signatureこのフィールドは、使用できる署名アルゴリズムを示します. 値は、匿名の署名、RSASSA-PKCS1-v1_5 [PKCS1]、DSA [DSS]、およびECDSA [ECDSA]をそれぞれ示します. 「匿名」の値はこのコンテキストでは意味がありませんが、7.4.3節で使用されています. それはこの拡張に現れてはいけません. 

暗号スイートが許容可能な署名アルゴリズムを示し、ハッシュアルゴリズムを示さないため、この拡張のセマンティクスは多少複雑です. セクション7.4.2および7.4.3は、適切なルールについて説明しています. 

クライアントがデフォルトのハッシュおよび署名アルゴリズム（このセクションにリストされている）のみをサポートしている場合、signature_algorithms拡張を省略してもよい（MAY）. クライアントがデフォルトのアルゴリズムをサポートしていない場合、または他のハッシュアルゴリズムと署名アルゴリズムをサポートしている場合（そして、サーバーから送信されたメッセージを確認するためにそれらを使用する意思がある場合（つまり、サーバー証明書とサーバーキー交換））、クライアントは、signature_algorithms拡張を送信する必要があります. 受け入れることをいとわないアルゴリズムのリスト. 

クライアントがsignature_algorithms拡張を送信しない場合、サーバーは以下を実行する必要があります.  

-ネゴシエートされたキー交換アルゴリズムが（RSA、DHE_RSA、DH_RSA、RSA_PSK、ECDH_RSA、ECDHE_RSA）のいずれかである場合、クライアントが値{sha1、rsa}を送信したかのように動作します.  

-ネゴシエートされたキー交換アルゴリズムが（DHE_DSS、DH_DSS）のいずれかである場合、クライアントが値{sha1、dsa}を送信したかのように動作します.  

-ネゴシエートされたキー交換アルゴリズムが（ECDH_ECDSA、ECDHE_ECDSA）のいずれかである場合、クライアントが値{sha1、ecdsa}を送信したかのように動作します.  

注：これは、明示的なルールがないTLS 1.1からの変更点ですが、実際には、ピアがMD5およびSHA-1をサポートしていると想定できます.  

注：この拡張機能は、1.2より前のTLSバージョンでは意味がありません. クライアントが以前のバージョンを提供している場合、クライアントはそれを提供してはなりません. ただし、クライアントが提供する場合でも、[TLSEXT]で指定されたルールでは、サーバーが理解していない拡張を無視する必要があります. 

サーバーはこの拡張機能を送信してはいけません. TLSサーバーは、この拡張機能の受信をサポートする必要があります. 

セッション再開を実行する場合、この拡張機能はServer Helloに含まれず、サーバーはClient Hello（存在する場合）の拡張機能を無視します.  

7.4.2.  Server Certificate

このメッセージが送信されるタイミング： 

合意された鍵交換方法が認証に証明書を使用するときはいつでも、サーバーは証明書メッセージを送信しなければなりません（これには、DH_anonを除く、このドキュメントで定義されたすべての鍵交換方法が含まれます）. このメッセージは、常にServerHelloメッセージの直後に続きます. 

このメッセージの意味： 

このメッセージは、サーバーの証明書チェーンをクライアントに伝えます.  

証明書は、交渉された暗号スイートの鍵交換アルゴリズムと交渉された拡張に適切でなければなりません（MUST）. このメッセージの構造：

      opaque ASN.1Cert<1..2^24-1>;

      struct {
          ASN.1Cert certificate_list<0..2^24-1>;
      } Certificate;

certificate_list証明書のシーケンス（チェーン）です. 送信者の証明書がリストの最初に来る必要があります. 次の各証明書は、その前の証明書を直接証明する必要があります. 証明書の検証では、ルートキーを個別に配布する必要があるため、ルート認証局を指定する自己署名証明書は、リモートエンドがそれを検証するためにすでに所有している必要があるという前提の下で、チェーンから省略される場合があります. 

証明書要求メッセージに対するクライアントの応答には、同じメッセージタイプと構造が使用されます. サーバーの認証要求に応答して送信する適切な証明書がない場合、クライアントは証明書を送信しない場合があります. 

注：PKCS＃6 [PKCS6]拡張証明書は使用されないため、PKCS＃7 [PKCS7]は証明書ベクトルの形式として使用されません. また、PKCS＃7はSEQUENCEではなくSETを定義しているため、リストの解析作業がより困難になります. 

サーバーから送信される証明書には、次のルールが適用されます.  

-明示的にネゴシエートされない限り（例：[TLSPGP]）、証明書のタイプはX.509v3でなければなりません（MUST）.  

-エンドエンティティ証明書の公開鍵（および関連する制限）は、選択した鍵交換アルゴリズムと互換性がある必要があります.  

鍵交換Alg. 証明書のキータイプ

RSA RSA公開鍵. 証明書は、RSA_PSKキーが暗号化に使用されることを許可する必要があります（キー使用拡張が存在する場合、keyEnciphermentビットを設定する必要があります）. 注：RSA_PSKは[TLSPSK]で定義されています. 

DHE_RSA RSA公開鍵. 証明書では、サーバーの鍵交換メッセージで使用される署名方式とハッシュアルゴリズムを使用して、ECDHE_RSA鍵を署名に使用できるようにする必要があります（鍵用途拡張が存在する場合はdigitalSignatureビットを設定する必要があります）. 注：ECDHE_RSAは[TLSECC]で定義されています. 

DHE_DSS DSA公開鍵. 証明書では、サーバーの鍵交換メッセージで使用されるハッシュアルゴリズムでの署名に鍵を使用できるようにする必要があります. 

DH_DSS Diffie-Hellman公開鍵. 鍵用途拡張が存在する場合、keyAgreementビットDH_RSAを設定する必要があります. 

ECDH_ECDSA ECDH対応の公開鍵. [TLSECC]で説明されているように、公開鍵は、クライアントがサポートする曲線と点の形式を使用する必要があります. 

ECDHE_ECDSA ECDSA対応の公開鍵. 証明書では、サーバーの鍵交換メッセージで使用されるハッシュアルゴリズムでの署名に鍵を使用できるようにする必要があります. [TLSECC]で説明されているように、公開鍵はクライアントがサポートする曲線と点の形式を使用する必要があります. 

-「server_name」および「trusted_ca_keys」拡張[TLSEXT]は、証明書の選択をガイドするために使用されます.  

クライアントが「signature_algorithms」拡張を提供した場合、サーバーによって提供されるすべての証明書は、その拡張に表示されるハッシュ/署名アルゴリズムのペアによって署名されなければなりません（MUST）. これは、ある署名アルゴリズムの鍵を含む証明書が、別の署名アルゴリズム（たとえば、DSA鍵で署名されたRSA鍵）を使用して署名される場合があることを意味することに注意してください. これは、アルゴリズムが同じであることが要求されたTLS 1.1からの逸脱です. これは、DH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSA鍵交換アルゴリズムが、証明書の署名に使用されるアルゴリズムを制限しないことも意味することに注意してください. 固定DH証明書は、拡張機能に表示されるハッシュ/署名アルゴリズムのペアで署名される場合があります. DH_DSS、DH_RSA、ECDH_ECDSA、およびECDH_RSAという名前は歴史的なものです. 

サーバーに複数の証明書がある場合、サーバーは上記の基準（トランスポート層のエンドポイント、ローカルの構成や設定などの他の基準に加えて）に基づいてそれらの1つを選択します. サーバーに単一の証明書がある場合、サーバーはこれらの基準を満たしていることを検証しようとする必要があります. 

現在TLSで使用できないアルゴリズムやアルゴリズムの組み合わせを使用する証明書があることに注意してください. たとえば、TLSは対応する署名アルゴリズムを定義していないため、RSASSA-PSS署名キー（SubjectPublicKeyInfoのid-RSASSA-PSS OID）を持つ証明書は使用できません. 

TLSプロトコルには新しい鍵交換方式を指定する暗号スイートが指定されているため、それらは証明書形式と必要なエンコードされた鍵情報を意味します.  


7.4.3.  Server Key Exchange Message

このメッセージが送信されるタイミング： 

このメッセージは、サーバーの証明書メッセージ（または匿名のネゴシエーションの場合はServerHelloメッセージ）の直後に送信されます.  

サーバー証明書メッセージ（送信された場合）に、クライアントがプリマスターシークレットを交換するのに十分なデータが含まれていない場合にのみ、ServerKeyExchangeメッセージがサーバーによって送信されます. これは、以下の鍵交換方法に当てはまります. 

DHE_DSS DHE_RSA DH_anon 

次の鍵交換方法でServerKeyExchangeメッセージを送信することはできません.  

RSA DH_DSS DH_RSA 

[TLSECC]で定義されているような他の鍵交換アルゴリズムは、ServerKeyExchangeメッセージが送信されるかどうかを指定しなければなりません. メッセージが送信された場合、その内容. 

このメッセージの意味： 

このメッセージは、クライアントがプリマスターシークレット（クライアントがキー交換を完了することができるDiffie-Hellman公開鍵（結果はプリマスターシークレット））または他のアルゴリズムの公開鍵を通信できるようにする暗号化情報を伝えます.  

このメッセージの構造： 

      enum { dhe_dss, dhe_rsa, dh_anon, rsa, dh_dss, dh_rsa
            /* may be extended, e.g., for ECDH -- see [TLSECC] */
           } KeyExchangeAlgorithm;

      struct {
          opaque dh_p<1..2^16-1>;
          opaque dh_g<1..2^16-1>;
          opaque dh_Ys<1..2^16-1>;
      } ServerDHParams;     /* Ephemeral DH parameters */

      dh_p
         The prime modulus used for the Diffie-Hellman operation.

      dh_g
         The generator used for the Diffie-Hellman operation.

      dh_Ys
         The server's Diffie-Hellman public value (g^X mod p). 

      struct {
          select (KeyExchangeAlgorithm) {
              case dh_anon:
                  ServerDHParams params;
              case dhe_dss:
              case dhe_rsa:
                  ServerDHParams params;
                  digitally-signed struct {
                      opaque client_random[32];
                      opaque server_random[32];
                      ServerDHParams params;
                  } signed_params;
              case rsa:
              case dh_dss:
              case dh_rsa:
                  struct {} ;
                 /* message is omitted for rsa, dh_dss, and dh_rsa */
              /* may be extended, e.g., for ECDH -- see [TLSECC] */
          };
      } ServerKeyExchange;

paramsサーバーの鍵交換パラメーター.  

signed_pa​​rams非匿名の鍵交換の場合、サーバーの鍵交換パラメーターに対する署名.  

クライアントが「signature_algorithms」拡張機能を提供している場合、署名アルゴリズムとハッシュアルゴリズムは、その拡張機能にリストされているペアである必要があります. ここで矛盾が生じる可能性があることに注意してください. たとえば、クライアントはDHE_DSS鍵交換を提供しますが、その「signature_algorithms」拡張からDSAペアを省略します. 正しくネゴシエートするために、サーバーは、候補となる暗号スイートを選択する前に、「signature_algorithms」拡張に対してチェックする必要があります. これは多少洗練されていませんが、元の暗号スイート設計への変更を最小限に抑えるように設計された妥協案です. 

さらに、ハッシュおよび署名アルゴリズムは、サーバーのエンドエンティティ証明書のキーと互換性がある必要があります. RSAキーは、許可されたハッシュアルゴリズムで使用することができます（ある場合）. 

DSA署名にはハッシュアルゴリズムの安全な表示が含まれていないため、任意のキーで複数のハッシュが使用される可能性がある場合は、ハッシュ置換のリスクがあります. 現在、DSA [DSS]はSHA-1でのみ使用できます. DSS [DSS-3]の将来の改訂では、DSAで他のダイジェストアルゴリズムを使用できるようになる予定であり、各ダイジェストアルゴリズムを各キーサイズで使用する必要があるかどうかに関するガイダンスも含まれます. さらに、[PKIX]の将来の改訂では、DSAで使用するダイジェストアルゴリズムを示す証明書のメカニズムを指定する可能性があります. 

新しいキー交換アルゴリズムを含む追加の暗号スイートがTLSに定義されているため、サーバー交換キーメッセージは、キー交換アルゴリズムに関連付けられた証明書タイプがクライアントがプリマスターシークレットを交換するのに十分な情報を提供しない場合にのみ送信されます.  

7.4.4.  Certificate Request

このメッセージが送信されるタイミング： 

非匿名サーバーは、選択した暗号スイートに適切であれば、オプションでクライアントに証明書を要求できます. このメッセージは、送信された場合、ServerKeyExchangeメッセージの直後に送信されます（送信された場合. 送信されなかった場合、このメッセージはサーバーの証明書メッセージの後に送信されます）. 

このメッセージの構造： 

      enum {
          rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
          rsa_ephemeral_dh_RESERVED(5), dss_ephemeral_dh_RESERVED(6),
          fortezza_dms_RESERVED(20), (255)
      } ClientCertificateType;

      opaque DistinguishedName<1..2^16-1>;

      struct {
          ClientCertificateType certificate_types<1..2^8-1>;
          SignatureAndHashAlgorithm
            supported_signature_algorithms<2^16-1>;
          DistinguishedName certificate_authorities<0..2^16-1>;
      } CertificateRequest;

   certificate_types
      A list of the types of certificate types that the client may
      offer.

         rsa_sign        a certificate containing an RSA key
         dss_sign        a certificate containing a DSA key
         rsa_fixed_dh    a certificate containing a static DH key.
         dss_fixed_dh    a certificate containing a static DH key

supported_signature_algorithms
サーバーが検証できるハッシュ/署名アルゴリズムのペアのリストで、優先度の高い順にリストされています.  

certificate_authorities 
DERエンコード形式で表された、受け入れ可能なcertificate_authoritiesの識別名[X501]のリスト. これらの識別名は、ルートCAまたは下位CAに必要な識別名を指定できます. したがって、このメッセージを使用して、既知のルートと必要な承認スペースを説明できます. certificate_authoritiesリストが空の場合、反対の外部配置がない限り、クライアントは適切なClientCertificateTypeの証明書を送信できます（MAY）. 

certificate_typesフィールドとsupported_signature_algorithmsフィールドの相互作用はやや複雑です. SSL_3以降、certificate_typesはTLSに存在していましたが、多少仕様が不十分でした. その機能の多くは、supported_signature_algorithmsに置き換えられています. 次の規則が適用されます. 

-クライアントが提供する証明書は、supported_signature_algorithmsにあるハッシュ/署名アルゴリズムのペアを使用して署名する必要があります.  

-クライアントが提供するエンドエンティティ証明書には、certificate_typesと互換性のあるキーを含める必要があります. 鍵が署名鍵の場合は、supported_signature_algorithmsのハッシュ/署名アルゴリズムのペアで使用できる必要があります. 

-歴史的な理由により、一部のクライアント証明書タイプの名前には、証明書の署名に使用されるアルゴリズムが含まれています. たとえば、TLSの以前のバージョンでは、rsa_fixed_dhはRSAで署名され、静的DHキーを含む証明書を意味していました. TLS 1.2では、この機能はsupported_signature_algorithmsによって廃止され、証明書の種類は証明書への署名に使用されるアルゴリズムを制限しなくなりました. たとえば、サーバーがdss_fixed_dh証明書タイプと{{sha1、dsa}、{sha1、rsa}}署名タイプを送信する場合、クライアントは、RSA-SHA1で署名された静的DHキーを含む証明書で応答できます. 

セクション12で説明されているように、新しいClientCertificateType値はIANAによって割り当てられます.  

注：RESERVEDとしてリストされている値は使用できません. SSLv3で使用されていました. 

注：匿名サーバーがクライアント認証を要求することは、致命的なhandshake_failureアラートです.  

7.4.5.  Server Hello Done

このメッセージが送信されるタイミング： 

ServerHelloDoneメッセージはサーバーによって送信され、ServerHelloと関連メッセージの終わりを示します. このメッセージを送信した後、サーバーはクライアントの応答を待ちます. 

このメッセージの意味： 

このメッセージは、サーバーがキー交換をサポートするメッセージの送信を完了し、クライアントがキー交換のフェーズを続行できることを意味します.  

ServerHelloDoneメッセージを受信すると、クライアントは、必要に応じてサーバーが有効な証明書を提供したことを確認し、サーバーのhelloパラメータが受け入れ可能であることを確認する必要があります.  

このメッセージの構造： 

struct {} ServerHelloDone; 

7.4.6.  Client Certificate

このメッセージが送信されるタイミング： 

これは、ServerHelloDoneメッセージを受信した後にクライアントが送信できる最初のメッセージです. このメッセージは、サーバーが証明書を要求した場合にのみ送信されます. 適切な証明書がない場合、クライアントは証明書を含まない証明書メッセージを送信する必要があります. つまり、certificate_list構造の長さはゼロです. クライアントが証明書を送信しない場合、サーバーは独自の裁量で、クライアント認証なしでハンドシェイクを続行するか、致命的なhandshake_failureアラートで応答する場合があります. また、証明書チェーンのある側面が受け入れられなかった場合（たとえば、既知の信頼されたCAによって署名されなかった場合）、サーバーはその裁量でハンドシェイクを続行するか（クライアントが認証されていないことを考慮して）、致命的なアラートを送信できます. 

クライアント証明書は、セクション7.4.2で定義された証明書構造を使用して送信されます.  

このメッセージの意味： 

このメッセージは、クライアントの証明書チェーンをサーバーに伝えます. サーバーは、CertificateVerifyメッセージの検証（クライアント認証が署名に基づいている場合）またはプリマスターシークレットの計算（非一時的なDiffie-Hellmanの場合）に使用します. 証明書は、交渉された暗号スイートの鍵交換アルゴリズム、および交渉された拡張に適切でなければなりません（MUST）. 

特に： 

-明示的にネゴシエートされない限り（例：[TLSPGP]）、証明書のタイプはX.509v3でなければなりません（MUST）.  

-エンドエンティティ証明書の公開キー（および関連する制限）は、CertificateRequestにリストされている証明書タイプと互換性がある必要があります.  

クライアント証明書. タイプ証明書のキータイプ

rsa_sign RSA公開鍵. 証明書は、証明書検証メッセージで使用される署名スキームとハッシュアルゴリズムで署名するために使用されるキーを許可する必要があります. 

dss_sign DSA公開鍵. 証明書は、証明書検証メッセージで使用されるハッシュアルゴリズムで署名するために使用されるキーを許可する必要があります. 

ecdsa_sign ECDSA対応の公開鍵. 証明書は、証明書検証メッセージで使用されるハッシュアルゴリズムで署名するために使用されるキーを許可する必要があります. 公開鍵は、サーバーがサポートする曲線と点の形式を使用する必要があります. 

rsa_fixed_dh Diffie-Hellman公開鍵. サーバーのキーと同じdss_fixed_dhパラメータを使用する必要があります. 

rsa_fixed_ecdh ECDH対応の公開鍵. ecdsa_fixed_ecdhはサーバーのキーと同じ曲線を使用する必要があり、サーバーがサポートするポイント形式を使用する必要があります. 

-証​​明書要求メッセージのcertificate_authoritiesリストが空でない場合、証明書チェーン内の証明書の1つは、リストされたCAの1つによって発行されるべきです（SHOULD）. -証​​明書は、セクション7.4.4で説明されているように、受け入れ可能なハッシュ/署名アルゴリズムのペアを使用して署名する必要があります. これにより、以前のバージョンのTLSにあった証明書署名アルゴリズムの制約が緩和されることに注意してください. 

サーバー証明書と同様に、現在TLSでは使用できないアルゴリズム/アルゴリズムの組み合わせを使用する証明書があることに注意してください.  

7.4.7. クライアントキー交換メッセージ

このメッセージが送信されるタイミング： 

このメッセージは常にクライアントによって送信されます. 送信される場合、クライアント証明書メッセージの直後に続く必要があります. それ以外の場合は、ServerHelloDoneメッセージを受信した後にクライアントが送信する最初のメッセージでなければなりません. 

このメッセージの意味： 

このメッセージでは、RSAで暗号化されたシークレットを直接送信するか、各サイドが同じプリマスターシークレットに同意できるDiffie-Hellmanパラメータを送信することによって、プリマスターシークレットが設定されます.  

クライアントが一時的なDiffie-Hellman指数を使用している場合、このメッセージにはクライアントのDiffie-Hellmanパブリック値が含まれます. クライアントが静的DH指数を含む証明書を送信している場合（つまり、fixed_dhクライアント認証を実行している場合）、このメッセージは送信する必要がありますが、空である必要があります. 

このメッセージの構造： 

メッセージの選択は、選択されている鍵交換方式によって異なります. KeyExchangeAlgorithmの定義については、7.4.3項を参照してください. 























struct {select（KeyExchangeAlgorithm）{case rsa：EncryptedPreMasterSecret; ケースdhe_dss：ケースdhe_rsa：ケースdh_dss：ケースdh_rsa：ケースdh_anon：ClientDiffieHellmanPublic; } exchange_keys; } ClientKeyExchange;

7.4.7.1. RSA暗号化プリマスターシークレットメッセージ

このメッセージの意味： 

RSAが鍵の合意と認証に使用されている場合、クライアントは48バイトのプリマスターシークレットを生成し、サーバーの証明書の公開鍵を使用してそれを暗号化し、暗号化されたプリマスターシークレットメッセージで結果を送信します. この構造はClientKeyExchangeメッセージのバリアントであり、それ自体はメッセージではありません. 

このメッセージの構造： 

struct {ProtocolVersion client_version; 不透明なランダム[46]; } PreMasterSecret;

client_versionクライアントがサポートする最新の（最新の）バージョン. これは、バージョンロールバック攻撃を検出するために使用されます. 

random 46の安全に生成されたランダムバイト.  

struct {public-key-encrypted PreMasterSecret pre_master_secret; } EncryptedPreMasterSecret;

pre_master_secretこのランダムな値はクライアントによって生成され、セクション8.1で指定されているように、マスターシークレットを生成するために使用されます.  





注：PreMasterSecretのバージョン番号は、クライアントがClientHello.client_versionで提供するバージョンであり、接続についてネゴシエートされたバージョンではありません. この機能は、ロールバック攻撃を防ぐように設計されています. 残念ながら、一部の古い実装では代わりにネゴシエートされたバージョンを使用するため、バージョン番号を確認すると、このような不適切なクライアント実装との相互運用に失敗する可能性があります. 

クライアントの実装は、常にPreMasterSecretで正しいバージョン番号を送信する必要があります. ClientHello.client_versionがTLS 1.1以上の場合、サーバーの実装は、以下のメモに記載されているようにバージョン番号を確認する必要があります. バージョン番号がTLS 1.0以前の場合、サーバー実装はバージョン番号をチェックする必要があります（SHOULD）が、チェックを無効にする構成オプションがある場合があります. チェックが失敗した場合、PreMasterSecretは以下で説明するようにランダム化する必要があることに注意してください. 

注：Bleichenbacher [BLEI]とKlimaらによって発見された攻撃. [KPR03]は、特定のメッセージが復号化されたときに、適切にPKCS＃1形式であるか、有効なPreMasterSecret構造を含むか、または正しいバージョン番号を持っているかを明らかにするTLSサーバーを攻撃するために使用できます. 

Klima [KPR03]で説明されているように、これらの脆弱性は、正しくフォーマットされたRSAブロックと区別できない方法で、誤ってフォーマットされたメッセージブロックや不一致のバージョン番号を処理することで回避できます. 言い換えると：

1.ランダムな46バイトの文字列Rを生成します 

2.メッセージを復号化して平文Mを復元する 

3. PKCS＃1パディングが正しくない場合、またはメッセージMの長さが正確に48バイトでない場合：pre_master_secret = ClientHello.client_version || R else ClientHello.client_version <= TLS 1.0で、バージョン番号のチェックが明示的に無効になっている場合：pre_master_secret = M else：pre_master_secret = ClientHello.client_version || M [2..47]

クライアントが元のpre_master_secretで間違ったバージョンを送信した場合、ClientHello.client_versionを使用して明示的にpre_master_secretを構築すると、無効なmaster_secretが生成されることに注意してください.  

別の方法は、バージョン番号の不一致をPKCS-1のフォーマットエラーとして扱い、プリマスターシークレットを完全にランダム化することです.  

1.ランダムな48バイトの文字列Rを生成します 

2.メッセージを復号化して平文Mを復元する 

3. PKCS＃1パディングが正しくない場合、またはメッセージMの長さが正確に48バイトでない場合：pre_master_secret = R else ClientHello.client_version <= TLS 1.0で、バージョン番号のチェックが明示的に無効になっている場合：premaster secret = M else If M [0..1]！= ClientHello.client_version：premaster secret = R else：premaster secret = M 

この構造に対する実際的な攻撃は知られていないが、クリマ等. [KPR03]は、いくつかの理論的な攻撃について説明しているため、説明されている最初の構成が推奨されます. 

いずれの場合でも、RSAで暗号化されたプリマスターシークレットメッセージの処理が失敗した場合、またはバージョン番号が期待どおりでない場合、TLSサーバーはアラートを生成してはなりません（MUST NOT）. 代わりに、ランダムに生成されたプリマスターシークレットを使用してハンドシェイクを継続する必要があります. トラブルシューティングの目的で、失敗の実際の原因をログに記録すると役立つ場合があります. ただし、攻撃者への情報の漏えい（たとえば、タイミング、ログファイル、またはその他のチャネルを通じて）を回避するように注意する必要があります. 

[PKCS1]で定義されているRSAES-OAEP暗号化スキームは、ブライチェンバッハ攻撃に対してより安全です. ただし、TLSの以前のバージョンとの互換性を最大限に高めるために、この仕様ではRSAES-PKCS1-v1_5スキームを使用しています. 上記の推奨事項に従う限り、ブライチェンバッハー攻撃の亜種は存在しないことがわかっています. 

実装上の注意：公開鍵で暗号化されたデータは、不透明なベクトル<0..2 ^ 16-1>として表されます（セクション4.7を参照）. したがって、ClientKeyExchange内のRSA暗号化されたPreMasterSecretの前には、2つの長さのバイトがあります. EncryptedPreMasterSecretはClientKeyExchange内の唯一のデータであり、その長さは明確に決定できるため、RSAの場合、これらのバイトは冗長です. SSLv3仕様では、公開鍵暗号化データのエンコードについて明確ではなかったため、多くのSSLv3実装には長さバイトが含まれていません. RSA暗号化データはClientKeyExchangeメッセージに直接エンコードされています. 

この仕様では、長さバイトで完全なEncryptedPreMasterSecretの正しいエンコードが必要です. 結果のPDUは、多くのSSLv3実装と互換性がありません. SSLv3からアップグレードする実装者は、正しいエンコーディングを生成して受け入れるように実装を変更する必要があります. SSLv3とTLSの両方との互換性を希望する実装者は、実装の動作をプロトコルバージョンに依存させる必要があります. 

実装メモ：少なくともクライアントとサーバーが同じLAN上にある場合、TLSに対するリモートタイミングベースの攻撃が可能であることが判明しました. したがって、静的なRSAキーを使用する実装では、[タイミング]で説明されているように、RSAブラインドまたはその他のアンチタイミング技術を使用する必要があります. 

7.4.7.2. クライアントDiffie-Hellmanパブリックバリュー

このメッセージの意味： 

この構造は、クライアントの証明書にまだ含まれていない場合、クライアントのDiffie-Hellmanパブリック値（Yc）を伝えます. Ycに使用されるエンコーディングは、列挙されたPublicValueEncodingによって決定されます. この構造はクライアント鍵交換メッセージの変形であり、それ自体はメッセージではありません. 

このメッセージの構造： 

列挙型{暗黙的、明示的} PublicValueEncoding; 

暗黙的クライアントが適切なDiffie-Hellmanキー（fixed_dhクライアント認証用）を含む証明書を送信した場合、Ycは暗黙的であり、再度送信する必要はありません. この場合、クライアントの鍵交換メッセージが送信されますが、空である必要があります. 

明示的なYcを送信する必要があります.  

struct {select（PublicValueEncoding）{暗黙のケース：struct {}; 明示的なケース：不透明なdh_Yc <1..2 ^ 16-1>; } dh_public; } ClientDiffieHellmanPublic;

dh_YcクライアントのDiffie-Hellman公開値（Yc）.  







7.4.8. 証明書の確認

このメッセージが送信されるタイミング： 

このメッセージは、クライアント証明書の明示的な検証を提供するために使用されます. このメッセージは、署名機能を持つクライアント証明書（つまり、固定Diffie-Hellmanパラメータを含むものを除くすべての証明書）に続いてのみ送信されます. 送信されると、クライアント鍵交換メッセージの直後に続く必要があります. 

このメッセージの構造： 

構造体{デジタル署名された構造体{不透明なhandshake_messages [handshake_messages_length]; }} CertificateVerify;

ここで、handshake_messagesは、クライアントのhelloから始まり、ハンドシェイクメッセージのタイプフィールドと長さフィールドを含む、このメッセージまでのすべてのハンドシェイクメッセージを指します. これは、これまでに交換されたすべてのハンドシェイク構造（7.4節で定義）を連結したものです. これには、CertificateVerifyの計算時まで、すべての潜在的なハッシュアルゴリズムについて、メッセージをバッファリングするか、実行中のハッシュを計算する必要があることに注意してください. サーバーは、CertificateRequestメッセージで制限された一連のダイジェストアルゴリズムを提供することにより、この計算コストを最小限に抑えることができます. 

署名で使用されるハッシュおよび署名アルゴリズムは、CertificateRequestメッセージのsupported_signature_algorithmsフィールドに存在するものの1つである必要があります. さらに、ハッシュおよび署名アルゴリズムは、クライアントのエンドエンティティ証明書のキーと互換性がある必要があります. RSAキーは、許可されたハッシュアルゴリズムで使用することができます（ある場合）. 

DSA署名にはハッシュアルゴリズムの安全な表示が含まれていないため、任意のキーで複数のハッシュが使用される可能性がある場合は、ハッシュ置換のリスクがあります. 現在、DSA [DSS]はSHA-1でのみ使用できます. DSS [DSS-3]の将来の改訂では、DSAで他のダイジェストアルゴリズムを使用できるようになる予定であり、各ダイジェストアルゴリズムを各キーサイズで使用する必要があるかどうかに関するガイダンスも含まれます. さらに、[PKIX]の将来の改訂では、DSAで使用するダイジェストアルゴリズムを示す証明書のメカニズムを指定する可能性があります. 

7.4.9. 完成した

このメッセージが送信されるタイミング： 

暗号仕様変更メッセージの直後に終了メッセージが常に送信され、鍵交換と認証プロセスが成功したことを確認します. 他のハンドシェイクメッセージと終了メッセージの間に暗号仕様変更メッセージを受信することが不可欠です. 

このメッセージの意味： 

Finishedメッセージは、交渉されたばかりのアルゴリズム、キー、およびシークレットで保護された最初のメッセージです. Finishedメッセージの受信者は、内容が正しいことを確認する必要があります. サイドが終了メッセージを送信し、ピアから終了メッセージを受信して​​検証すると、接続を介してアプリケーションデータの送受信を開始できます. 

このメッセージの構造： 

struct {不透明なverify_data [verify_data_length]; }終了しました. 

verify_data PRF（master_secret、finished_label、Hash（handshake_messages））[0..verify_data_length-1]; 

finished_labelクライアントによって送信された終了メッセージの場合、ストリング「client finished」. サーバーによって送信された終了メッセージの場合、文字列「サーバー終了」. 

ハッシュは、ハンドシェイクメッセージのハッシュを示します. セクション5で定義されたPRFの場合、ハッシュはPRFの基礎として使用されるハッシュでなければなりません. 異なるPRFを定義する暗号スイートは、Finished計算で使用するハッシュも定義する必要があります. 

以前のバージョンのTLSでは、verify_dataは常に12オクテット長でした. TLSの現在のバージョンでは、暗号スイートに依存しています. verify_data_lengthを明示的に指定しない暗号スイートは、verify_data_lengthが12です. これには、既存のすべての暗号スイートが含まれます. この表現のエンコーディングは、以前のバージョンと同じであることに注意してください. 将来の暗号スイートは他の長さを指定するかもしれませんが、そのような長さは少なくとも12バイトでなければなりません（MUST）. 

handshake_messagesこのハンドシェイク内のすべてのメッセージ（HelloRequestメッセージは含まない）からこのメッセージまでのすべてのデータ. これは、ハンドシェイクレイヤーでのみ表示されるデータであり、レコードレイヤーヘッダーは含まれません. これは、これまでに交換された、セクション7.4で定義されたすべてのハンドシェイク構造の連結です. 

ハンドシェイクの適切な時点で、完了メッセージの前にChangeCipherSpecメッセージがない場合は、致命的なエラーです.  

値handshake_messagesには、ClientHelloで開始してこのFinishedメッセージまでのすべてのハンドシェイクメッセージが含まれますが、含まれません. これは、CertificateVerifyメッセージ（送信された場合）が含まれるため、セクション7.4.8のhandshake_messagesとは異なる場合があります. また、クライアントが送信した終了メッセージのhandshake_messagesは、サーバーが送信した終了メッセージのhandshake_messagesとは異なります. これは、2番目に送信されるメッセージに前のメッセージが含まれるためです. 

注：ChangeCipherSpecメッセージ、アラート、およびその他のレコードタイプはハンドシェイクメッセージではないため、ハッシュ計算には含まれません. また、HelloRequestメッセージはハンドシェイクハッシュから省略されます. 

8.暗号計算 

接続保護を開始するには、TLSレコードプロトコルで一連のアルゴリズム、マスターシークレット、およびクライアントとサーバーのランダム値を指定する必要があります. 認証、暗号化、およびMACアルゴリズムは、サーバーによって選択され、ServerHelloメッセージで明らかにされたcipher_suiteによって決定されます. 圧縮アルゴリズムはhelloメッセージでネゴシエートされ、ランダムな値がhelloメッセージで交換されます. あとは、マスターシークレットを計算するだけです. 

8.1. マスターシークレットの計算

すべての鍵交換方式で、同じアルゴリズムを使用してpre_master_secretをmaster_secretに変換します. master_secretが計算されたら、pre_master_secretをメモリから削除する必要があります. 

master_secret = PRF（pre_master_secret、 "master secret"、ClientHello.random + ServerHello.random）[0..47]; 

マスターシークレットの長さは常に正確に48バイトです. プリマスターシークレットの長さは、鍵の交換方法によって異なります. 8.1.1. RSA

RSAがサーバー認証と鍵交換に使用される場合、48バイトのpre_master_secretがクライアントによって生成され、サーバーの公開鍵で暗号化されてサーバーに送信されます. サーバーは、その秘密鍵を使用してpre_master_secretを復号化します. 次に、両方の当事者が、上記のようにpre_master_secretをmaster_secretに変換します. 

8.1.2. ディフィーヘルマン

従来のDiffie-Hellman計算が実行されます. ネゴシエートされたキー（Z）はpre_master_secretとして使用され、上記のようにmaster_secretに変換されます. すべてゼロのビットを含むZの先頭バイトは、pre_master_secretとして使用される前に取り除かれます. 

注：Diffie-Hellmanパラメーターはサーバーによって指定され、一時的であるか、サーバーの証明書内に含まれている可能性があります.  

9.必須の暗号スイート 

特に指定しないアプリケーションプロファイル標準がない場合、TLS準拠のアプリケーションは、暗号スイートTLS_RSA_WITH_AES_128_CBC_SHAを実装する必要があります（定義については、付録A.5を参照してください）.  

10.アプリケーションデータプロトコル 

アプリケーションデータメッセージはレコードレイヤーによって運ばれ、現在の接続状態に基づいて断片化、圧縮、および暗号化されます. メッセージは、レコードレイヤーに対して透過的なデータとして扱われます. 

11.セキュリティに関する考慮事項 

セキュリティの問題は、このメモ全体で、特に付録D、E、Fで説明されています.  

12. IANAに関する考慮事項 

このドキュメントでは、最初に[TLS1.1]で作成されたいくつかのレジストリを使用します. IANAは、このドキュメントを参照するようにこれらを更新しました. レジストリとその割り当てポリシー（[TLS1.1]から変更なし）を以下に示します. 





-TLS ClientCertificateType Identifiers Registry：0〜63（10進数）の範囲の将来の値は、標準アクション[RFC2434]を介して割り当てられます. 64-223（10進数）を含む範囲の値は、Specification Required [RFC2434]によって割り当てられます. 224-255（10進数）を含む値は、私的使用[RFC2434]のために予約されています. 

-TLS暗号スイートレジストリ：最初のバイトが0〜191（10進数）の範囲にある将来の値は、標準アクション[RFC2434]を介して割り当てられます. 192〜254（10進数）の範囲の最初のバイトの値は、Specification Required [RFC2434]によって割り当てられます. 最初のバイトが255（10進数）の値は、個人使用のために予約されています[RFC2434]. 

-このドキュメントでは、いくつかの新しいHMAC-SHA256ベースの暗号スイートを定義しています. その値（付録A.5）は、TLS暗号スイートレジストリから割り当てられています.  

-TLS ContentTypeレジストリ：標準アクション[RFC2434]を介して将来の値が割り当てられます.  

-TLS Alert Registry：将来の値は、標準アクション[RFC2434]によって割り当てられます.  

-TLS HandshakeType Registry：将来の値は、標準アクション[RFC2434]を介して割り当てられます.  

このドキュメントでは、[RFC4366]で最初に作成されたレジストリも使用しています. IANAは、このドキュメントを参照するように更新しました. レジストリとその割り当てポリシー（[RFC4366]から変更なし）を以下に示します. 

-TLS ExtensionType Registry：IETFコンセンサス[RFC2434]を介して将来の値が割り当てられます. IANAはこのレジストリを更新して、signature_algorithms拡張機能とそれに対応する値を追加しました（セクション7.4.1.4を参照）. 

さらに、このドキュメントでは、IANAによって維持される2つの新しいレジストリを定義しています.  

-TLS SignatureAlgorithmレジストリ：レジストリには、セクション7.4.1.4.1で説明されている値が最初に入力されています. 0〜63（10進数）の範囲の将来の値は、標準アクション[RFC2434]を介して割り当てられます. 64-223（10進数）を含む範囲の値は、Specification Required [RFC2434]によって割り当てられます. 224-255（10進数）を含む値は、私的使用[RFC2434]のために予約されています. 



-TLS HashAlgorithmレジストリ：レジストリには、セクション7.4.1.4.1で説明されている値が最初に入力されています. 0〜63（10進数）の範囲の将来の値は、標準アクション[RFC2434]を介して割り当てられます. 64-223（10進数）を含む範囲の値は、Specification Required [RFC2434]によって割り当てられます. 224-255（10進数）を含む値は、私的使用[RFC2434]のために予約されています. 

このドキュメントでは、[RFC3749]で定義されているTLS圧縮方式識別子レジストリも使用しています. IANAは、「null」圧縮方式に値0を割り当てました. 





付録A.プロトコルデータ構造と定数値 

このセクションでは、プロトコルのタイプと定数について説明します.  

A.1. レコードレイヤー

struct {uint8 major; uint8マイナー. } ProtocolVersion;

ProtocolVersionバージョン= {3、3}; / * TLS v1.2 * /

列挙型{change_cipher_spec（20）、alert（21）、handshake（22）、application_data（23）、（255）} ContentType; 

struct {ContentTypeタイプ. ProtocolVersionバージョン. uint16の長さ. 不透明なフラグメント[TLSPlaintext.length]; } TLSPlaintext;

struct {ContentTypeタイプ. ProtocolVersionバージョン. uint16の長さ. 不透明なフラグメント[TLSCompressed.length]; } TLSCompressed;

struct {ContentTypeタイプ. ProtocolVersionバージョン. uint16の長さ. select（SecurityParameters.cipher_type）{ケースストリーム：GenericStreamCipher; ケースブロック：GenericBlockCipher; ケースaead：GenericAEADCipher; }フラグメント. } TLSCiphertext;

ストリーム暗号化された構造体{不透明なコンテンツ[TLSCompressed.length]; 不透明なMAC [SecurityParameters.mac_length]; } GenericStreamCipher;

struct {opaque IV [SecurityParameters.record_iv_length]; ブロック暗号化された構造体{不透明なコンテンツ[TLSCompressed.length]; 不透明なMAC [SecurityParameters.mac_length]; uint8 padding [GenericBlockCipher.padding_length]; uint8 padding_length; }; } GenericBlockCipher;

struct {opaque nonce_explicit [SecurityParameters.record_iv_length]; aead-ciphered struct {opaque content [TLSCompressed.length]; }; } GenericAEADCipher;

A.2. 暗号仕様メッセージの変更

struct {enum {change_cipher_spec（1）、（255）} type; } ChangeCipherSpec;

A.3. 警告メッセージ

列挙型{warning（1）、fatal（2）、（255）} AlertLevel; 

列挙型{close_notify（0）、unexpected_message（10）、bad_record_mac（20）、decryption_failed_RESERVED（21）、record_overflow（22）、decompression_failure（30）、handshake_failure（40）、no_certificate_RESERVED（41）、bad_certificate（42）、unsupported_certific ）、certificate_revoked（44）、certificate_expired（45）、certificate_unknown（46）、illegal_parameter（47）、unknown_ca（48）、access_denied（49）、decode_error（50）、decrypt_error（51）、export_restriction_RESERVED（60）、protocol_version（70 ）、不十分なセキュリティ（71）、内部エラー（80）、ユーザーキャンセル（90）、no_renegotiation（100）、サポートされていない拡張（110）、/ *新規* /（255）} AlertDescription; 

struct {AlertLevel level; AlertDescriptionの説明. }アラート. 

A.4. ハンドシェイクプロトコル

列挙型{hello_request（0）、client_hello（1）、server_hello（2）、certificate（11）、server_key_exchange（12）、certificate_request（13）、server_hello_done（14）、certificate_verify（15）、client_key_exchange（16）、finished（20 ）（255）} HandshakeType; 

struct {HandshakeType msg_type; uint24の長さ. select（HandshakeType）{case hello_request：HelloRequest; ケースclient_hello：ClientHello; case server_hello：ServerHello; ケース証明書：証明書; ケースserver_key_exchange：ServerKeyExchange; case certificate_request：CertificateRequest; case server_hello_done：ServerHelloDone; case certificate_verify：CertificateVerify; ケースclient_key_exchange：ClientKeyExchange; ケース終了：終了. } 体; }ハンドシェイク. 















A.4.1. こんにちはメッセージ

struct {} HelloRequest; 

struct {uint32 gmt_unix_time; 不透明なrandom_bytes [28]; }ランダム. 

不透明なSessionID <0..32>; 

uint8 CipherSuite [2]; 

列挙型{null（0）、（255）} CompressionMethod; 

struct {ProtocolVersion client_version; ランダムランダム; SessionID session_id; CipherSuite cipher_suites <2..2 ^ 16-2>; CompressionMethod compression_methods <1..2 ^ 8-1>; select（extensions_present）{case false：struct {}; trueの場合：Extension extensions <0..2 ^ 16-1>; }; } ClientHello;

struct {ProtocolVersion server_version; ランダムランダム; SessionID session_id; CipherSuite cipher_suite; CompressionMethod compression_method; select（extensions_present）{case false：struct {}; trueの場合：Extension extensions <0..2 ^ 16-1>; }; } ServerHello;

struct {ExtensionType extension_type; 不透明なextension_data <0..2 ^ 16-1>; }拡張. 

列挙型{signature_algorithms（13）、（65535）} ExtensionType; 

enum {none（0）、md5（1）、sha1（2）、sha224（3）、sha256（4）、sha384（5）、sha512（6）、（255）} HashAlgorithm; 列挙型{anonymous（0）、rsa（1）、dsa（2）、ecdsa（3）、（255）} SignatureAlgorithm;

struct {HashAlgorithmハッシュ; SignatureAlgorithm署名. } SignatureAndHashAlgorithm;

SignatureAndHashAlgorithm supported_signature_algorithms <2..2 ^ 16-1>; 

A.4.2. サーバー認証と主要交換メッセージ

不透明なASN.1Cert <2 ^ 24-1>; 

struct {ASN.1Cert certificate_list <0..2 ^ 24-1>; }証明書;

enum {dhe_dss、dhe_rsa、dh_anon、rsa、dh_dss、dh_rsa / * ECDHの場合など、拡張できます-[TLSECC]を参照してください* /} KeyExchangeAlgorithm; 

struct {opaque dh_p <1..2 ^ 16-1>; 不透明dh_g <1..2 ^ 16-1>; 不透明dh_Ys <1..2 ^ 16-1>; } ServerDHParams; / *エフェメラルDHパラメータ* /





















struct {select（KeyExchangeAlgorithm）{case dh_anon：ServerDHParams params; case dhe_dss：case dhe_rsa：ServerDHParams params; デジタル署名された構造体{不透明なclient_random [32]; 不透明なserver_random [32]; ServerDHParams params; } signed_pa​​rams; ケースrsa：ケースdh_dss：ケースdh_rsa：構造体{}; / * rsa、dh_dss、およびdh_rsaの場合はメッセージが省略されます* / / * ECDHなどの場合は拡張される可能性があります-[TLSECC]を参照してください* /} ServerKeyExchange;

列挙型{rsa_sign（1）、dss_sign（2）、rsa_fixed_dh（3）、dss_fixed_dh（4）、rsa_ephemeral_dh_RESERVED（5）、dss_ephemeral_dh_RESERVED（6）、fortezza_dms_RESERVED（20）、（255）、（255） 

不透明なDistinguishedName <1..2 ^ 16-1>; 

struct {ClientCertificateType certificate_types <1..2 ^ 8-1>; DistinguishedName certificate_authorities <0..2 ^ 16-1>; } CertificateRequest;

struct {} ServerHelloDone; 

























A.4.3. クライアント認証と主要交換メッセージ

struct {select（KeyExchangeAlgorithm）{case rsa：EncryptedPreMasterSecret; ケースdhe_dss：ケースdhe_rsa：ケースdh_dss：ケースdh_rsa：ケースdh_anon：ClientDiffieHellmanPublic; } exchange_keys; } ClientKeyExchange;

struct {ProtocolVersion client_version; 不透明なランダム[46]; } PreMasterSecret;

struct {public-key-encrypted PreMasterSecret pre_master_secret; } EncryptedPreMasterSecret;

列挙型{暗黙的、明示的} PublicValueEncoding; 

struct {select（PublicValueEncoding）{暗黙の場合：struct {}; 明示的なケース：不透明なDH_Yc <1..2 ^ 16-1>; } dh_public; } ClientDiffieHellmanPublic;

構造体{デジタル署名された構造体{不透明なhandshake_messages [handshake_messages_length]; }} CertificateVerify;

A.4.4. ハンドシェイク終了メッセージ

struct {不透明なverify_data [verify_data_length]; }終了しました. 







A.5. 暗号スイート

次の値は、ClientHelloおよびServerHelloメッセージで使用される暗号スイートコードを定義します.  

暗号スイートは、TLSバージョン1.2でサポートされる暗号仕様を定義します.  

TLS_NULL_WITH_NULL_NULLが指定されており、そのチャネルでの最初のハンドシェイク中のTLS接続の初期状態ですが、セキュリティで保護されていない接続以上の保護は提供されないため、ネゴシエートしてはなりません.  

CipherSuite TLS_NULL_WITH_NULL_NULL = {0x00,0x00}; 

以下のCipherSuite定義では、サーバーが鍵交換に使用できるRSA証明書を提供する必要があります. サーバーは、証明書要求メッセージで署名可能な証明書を要求できます. 

CipherSuite TLS_RSA_WITH_NULL_MD5 = {0x00,0x01}; CipherSuite TLS_RSA_WITH_NULL_SHA = {0x00,0x02}; CipherSuite TLS_RSA_WITH_NULL_SHA256 = {0x00,0x3B}; CipherSuite TLS_RSA_WITH_RC4_128_MD5 = {0x00,0x04}; CipherSuite TLS_RSA_WITH_RC4_128_SHA = {0x00,0x05}; CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA = {0x00,0x0A}; CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA = {0x00,0x2F}; CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA = {0x00,0x35}; CipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256 = {0x00,0x3C}; CipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x3D};

次の暗号スイート定義は、サーバー認証（およびオプションでクライアント認証）Diffie-Hellmanに使用されます. DHは、サーバーの証明書に認証局（CA）によって署名されたDiffie-Hellmanパラメーターが含まれている暗号スイートを示します. DHEは、一時的なDiffie-Hellmanを示します. Diffie-Hellmanパラメータは、CAによって署名された署名対応証明書によって署名されます. サーバーが使用する署名アルゴリズムは、CipherSuite名のDHEコンポーネントの後に指定されます. サーバーは、クライアント認証のためにクライアントから署名可能な証明書を要求できます. または、Diffie-Hellman証明書を要求することもできます. クライアントが提供するDiffie-Hellman証明書は、サーバーが記述するパラメーター（グループとジェネレーター）を使用する必要があります. 







CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA = {0x00,0x0D}; CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA = {0x00,0x10}; CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA = {0x00,0x13}; CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA = {0x00,0x16}; CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA = {0x00,0x30}; CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA = {0x00,0x31}; CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA = {0x00,0x32}; CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA = {0x00,0x33}; CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA = {0x00,0x36}; CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA = {0x00,0x37}; CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA = {0x00,0x38}; CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA = {0x00,0x39}; CipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256 = {0x00,0x3E}; CipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256 = {0x00,0x3F}; CipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 = {0x00,0x40}; CipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = {0x00,0x67}; CipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256 = {0x00,0x68}; CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x69}; CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = {0x00,0x6A}; CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x6B}; CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x69}; CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = {0x00,0x6A}; CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x6B}; CipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x69}; CipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 = {0x00,0x6A}; CipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = {0x00,0x6B};

次の暗号スイートは、どちらの当事者も認証されない完全に匿名のDiffie-Hellman通信に使用されます. このモードは中間者攻撃に対して脆弱であることに注意してください. したがって、このモードの使用は制限されています. これらの暗号スイートは、アプリケーション層が匿名キー交換を許可するように特別に要求していない限り、TLS 1.2実装で使用してはなりません（MUST NOT）. （たとえば、認証の設定が行われていない場合や、認証を保証する他の手段を持つより複雑なセキュリティプロトコルの一部としてTLSが使用されている場合など、日和見暗号化をサポートするために、匿名の鍵交換が受け入れられる場合があります. ）

CipherSuite TLS_DH_anon_WITH_RC4_128_MD5 = {0x00,0x18}; CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA = {0x00,0x1B}; CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA = {0x00,0x34}; CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA = {0x00,0x3A}; CipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256 = {0x00,0x6C}; CipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256 = {0x00,0x6D};

キー交換を実際に確認せずに非匿名キー交換を使用することは、本質的に匿名キー交換と同等であり、同じ予防策が適用されることに注意してください. 非匿名キー交換は、一般に匿名キー交換よりも高い計算コストと通信コストを伴いますが、アプリケーション層で匿名キー交換が許可されている場合に非匿名キー交換を無効にしないことは相互運用性の利益になる場合があります. 

セクション12で説明されているように、新しい暗号スイート値がIANAによって割り当てられています.  

注：暗号スイートの値{0x00、0x1C}および{0x00、0x1D}は、SSL 3のFortezzaベースの暗号スイートとの衝突を避けるために予約されています.  

A.6. セキュリティパラメータ

これらのセキュリティパラメータはTLSハンドシェイクプロトコルによって決定され、接続状態を初期化するためにパラメータとしてTLSレコードレイヤに提供されます. SecurityParametersには以下が含まれます. 

列挙型{null（0）、（255）} CompressionMethod; 

列挙型{サーバー、クライアント} ConnectionEnd; 

列挙型{tls_prf_sha256} PRFAlgorithm; 

enum {null、rc4、3des、aes} BulkCipherAlgorithm; 

enum {stream、block、aead} CipherType; 

列挙型{null、hmac_md5、hmac_sha1、hmac_sha256、hmac_sha384、hmac_sha512} MACAlgorithm; 

/ * CompressionMethod、PRFAlgorithm、BulkCipherAlgorithm、およびMACAlgorithmで指定されたアルゴリズムに他の値が追加される場合があります. * /

構造体{ConnectionEndエンティティ; PRFAlgorithm prf_algorithm; BulkCipherAlgorithm bulk_cipher_algorithm; CipherType cipher_type; uint8 enc_key_length; uint8 block_length; uint8 fixed_iv_length; uint8 record_iv_length; MACAlgorithm mac_algorithm; uint8 mac_length; uint8 mac_key_length; CompressionMethod compression_algorithm; 不透明なmaster_secret [48]; 不透明なclient_random [32]; 不透明なserver_random [32]; } SecurityParameters;

A.7. RFC 4492の変更

RFC 4492 [TLSECC]は、楕円曲線暗号スイートをTLSに追加します. このドキュメントは、そのドキュメントで使用されている構造の一部を変更します. このセクションでは、RFC 4492とTLS 1.2の両方の実装者に必要な変更について詳しく説明します. RFC 4492を実装していないTLS 1.2の実装者は、このセクションを読む必要はありません. 

このドキュメントは、署名を作成するために使用される署名とダイジェストアルゴリズムを識別するために、デジタル署名された要素に「signature_algorithm」フィールドを追加します. この変更はECDSAを使用して形成されたデジタル署名にも適用されるため、ECHA署名をSHA-1以外のダイジェストアルゴリズムで使用できるようになります. ただし、その使用が証明書および[PKIX]の将来のリビジョンによって課される制限と互換性がある場合に限ります. 

セクション7.4.2および7.4.6で説明されているように、証明書の署名に使用される署名アルゴリズムの制限は、暗号スイート（サーバーで使用される場合）またはClientCertificateType（クライアントで使用される場合）に関連付けられなくなりました. したがって、RFC 4492のセクション2と3で指定された証明書の署名に使用されるアルゴリズムの制限も緩和されます. このドキュメントのように、エンドエンティティ証明書のキーの制限は残ります. 

付録B用語集 

Advanced Encryption Standard（AES）AES [AES]は、広く使用されている対称暗号化アルゴリズムです. AESは、128ビット、192ビット、または256ビットの鍵と16バイトのブロックサイズを持つブロック暗号です. TLSは現在、128ビットおよび256ビットの鍵サイズのみをサポートしています. 

アプリケーションプロトコルアプリケーションプロトコルは、通常、トランスポート層（TCP / IPなど）の上に直接階層化されるプロトコルです. 例としては、HTTP、TELNET、FTP、SMTPなどがあります. 

非対称暗号公開鍵暗号を参照してください.  

認証済みの追加データ付き暗号化（AEAD）機密性とメッセージの整合性を同時に提供する対称暗号化アルゴリズム.  

認証認証とは、あるエンティティが別のエンティティのIDを決定する機能です.  

ブロック暗号ブロック暗号は、ブロックと呼ばれるビットのグループでプレーンテキストを操作するアルゴリズムです. 一般的なブロックサイズは64ビットで、128ビットです. 

バルク暗号大量のデータを暗号化するために使用される対称暗号化アルゴリズム.  

暗号ブロック連鎖（CBC）CBCは、ブロック暗号で暗号化されたすべての平文ブロックが、前の暗号テキストブロック（または、最初のブロックの場合は、初期化ベクトル）と最初に排他的ORされるモードです. 復号化では、すべてのブロックが最初に復号化され、次に前の暗号文ブロック（またはIV）と排他的論理和がとられます. 

証明書X.509プロトコル（別名ISO認証フレームワーク）の一部として、証明書は信頼できる認証局によって割り当てられ、パーティのIDまたはその他の属性とその公開鍵の間の強力なバインディングを提供します.  

クライアントサーバーへのTLS接続を開始するアプリケーションエンティティ. これは、クライアントが基になるトランスポート接続を開始したことを意味する場合とそうでない場合があります. サーバーとクライアントの主な運用上の違いは、サーバーは通常認証されるのに対し、クライアントはオプションでのみ認証されることです. 

クライアント書き込みキークライアントによって書き込まれたデータを暗号化するために使用されるキー.  

クライアント書き込みMACキークライアントによって書き込まれたデータを認証するために使用される秘密データ.  

接続接続は、適切なタイプのサービスを提供するトランスポート（OSIレイヤーモデル定義内）です. TLSの場合、そのような接続はピアツーピアの関係です. 接続は一時的です. すべての接続は1つのセッションに関連付けられています. 

Data Encryption Standard DES [DES]は、現在はかなり弱いと考えられていますが、依然として非常に広く使用されている対称暗号化アルゴリズムです. DESは、56ビットの鍵と8バイトのブロックサイズを持つブロック暗号です. TLSでは、鍵生成の目的で、DESは8バイトの鍵長（64ビット）を持つものとして扱われますが、それでも56ビットの保護しか提供しません. （各キーバイトの下位ビットは、そのキーバイトで奇数パリティを生成するように設定されていると想定されています. ）DESは、[3DES]モードでも操作できます. これは、168ビットの鍵（TLS鍵生成方式では24バイト）を使用し、112ビットのセキュリティと同等のものを提供します. 

デジタル署名標準（DSS）NIST FIPS PUB 186-2「デジタル署名標準」で定義された、国立標準技術研究所によって承認されたデジタル署名アルゴリズムを含むデジタル署名の標準. 商取引[DSS]. 重要な更新[DSS-3]が起草され、2006年3月に公開されました. 

デジタル署名デジタル署名は、公開鍵暗号と一方向ハッシュ関数を利用して、認証が可能であり、偽造または否認が難しいデータの署名を生成します.  

ハンドシェイクトランザクションのパラメータを確立するクライアントとサーバー間の初期のネゴシエーション.  

初期化ベクトル（IV）CBCモードでブロック暗号が使用される場合、初期化ベクトルは、暗号化の前に最初の平文ブロックと排他的論理和がとられます.  

メッセージ認証コード（MAC）メッセージ認証コードは、メッセージといくつかの秘密データから計算された一方向のハッシュです. 秘密のデータを知らずに偽造することは困難です. その目的は、メッセージが変更されたかどうかを検出することです. 

マスターシークレット暗号化キー、MACシークレット、およびIVの生成に使用される安全なシークレットデータ.  

MD5 MD5 [MD5]は、任意の長いデータストリームを固定サイズ（16バイト）のハッシュに変換するハッシュ関数です. 暗号解読が大幅に進歩したため、このドキュメントの公開時点では、MD5は「安全な」ハッシュ関数と見なすことはできません. 







公開キー暗号化2キー暗号を使用する暗号化技術のクラス. 公開鍵で暗号化されたメッセージは、関連付けられた秘密鍵でのみ復号化できます. 逆に、秘密鍵で署名されたメッセージは、公開鍵で検証できます. 

一方向ハッシュ関数任意量のデータを固定長ハッシュに変換する一方向変換. 変換を元に戻したり、衝突を見つけることは、計算上困難です. MD5およびSHAは、一方向ハッシュ関数の例です. 

RC4 Ron Rivestが発明したストリーム暗号. 互換性のある暗号は[SCH]で説明されています. 

RSA暗号化またはデジタル署名のいずれかに使用できる、非常に広く使用されている公開鍵アルゴリズム. [RSA]

サーバーサーバーは、クライアントからの接続要求に応答するアプリケーションエンティティです. 「クライアント」も参照してください. 

セッションTLSセッションは、クライアントとサーバー間の関連付けです. セッションは、ハンドシェイクプロトコルによって作成されます. セッションは、複数の接続間で共有できる一連の暗号化セキュリティパラメータを定義します. セッションは、各接続の新しいセキュリティパラメータの高価なネゴシエーションを回避するために使用されます. 

セッション識別子セッション識別子は、特定のセッションを識別するサーバーによって生成される値です.  

サーバー書き込みキーサーバーによって書き込まれたデータを暗号化するために使用されるキー.  

サーバー書き込みMACキーサーバーによって書き込まれたデータを認証するために使用される秘密データ.  

SHAセキュアハッシュアルゴリズム[SHS]は、FIPS PUB 180-2で定義されています. 20バイトの出力を生成します. SHAへのすべての参照（数値のサフィックスなし）は、実際には変更されたSHA-1アルゴリズムを使用することに注意してください. 



SHA-256 256ビットのセキュアハッシュアルゴリズムは、FIPS PUB 180-2で定義されています. 32バイトの出力を生成します. 

SSL NetscapeのSecure Socket Layerプロトコル[SSL3]. TLSはSSLバージョン3.0に基づいています. 

ストリーム暗号鍵を暗号的に強力な鍵ストリームに変換する暗号化アルゴリズム. 次に、平文と排他的論理和がとられます.  

対称暗号バルク暗号を参照してください.  

トランスポート層セキュリティ（TLS）このプロトコル. また、Internet Engineering Task Force（IETF）のTransport Layer Securityワーキンググループ. このドキュメントの最後にある「ワーキンググループ情報」を参照してください（P. 99）. 


付録C.暗号スイートの定義 

Cipher Suite Key Cipher Mac Exchange 

TLS_NULL_WITH_NULL_NULL NULL NULL NULL TLS_RSA_WITH_NULL_MD5 RSA NULL MD5 TLS_RSA_WITH_NULL_SHA RSA NULL SHA TLS_RSA_WITH_NULL_SHA256 RSA NULL SHA256 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA RSA AES_128_CBC SHA TLS_RSA_WITH_AES_256_CBC_SHA RSA AES_256_CBC SHA TLS_RSA_WITH_AES_128_CBC_SHA256 RSA AES_128_CBC SHA256 TLS_RSA_WITH_AES_256_CBC_SHA256 RSA AES_256_CBC SHA256 TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHATLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA TLS_DH_DSS_WITH_AES_128_CBC_SHA DH_DSS AES_128_CBC SHA TLS_DH_RSA_WITH_AES_128_CBC_SHA DH_RSA AES_128_CBC SHA TLS_DHE_DSS_WITH_AES_128_CBC_SHA DHE_DSS AES_128_CBC SHA TLS_DHE_RSA_WITH_AES_128_CBC_SHA DHE_RSA AES_128_CBC SHA TLS_DH_anon_WITH_AES_128_CBC_SHA DH_anon AES_128_CBC SHA TLS_DH_DSS_WITH_AES_256_CBC_SHA DH_DSS AES_256_CBC SHA TLS_DH_RSA_WITH_AES_256_CBC_SHA DH_RSA AES_256_CBC SHATLS_DHE_DSS_WITH_AES_256_CBC_SHA DHE_DSS AES_256_CBC SHA TLS_DHE_RSA_WITH_AES_256_CBC_SHA DHE_RSA AES_256_CBC SHA TLS_DH_anon_WITH_AES_256_CBC_SHA DH_anon AES_256_CBC SHA TLS_DH_DSS_WITH_AES_128_CBC_SHA256 DH_DSS AES_128_CBC SHA256 TLS_DH_RSA_WITH_AES_128_CBC_SHA256 DH_RSA AES_128_CBC SHA256 TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 DHE_DSS AES_128_CBC SHA256 TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 DHE_RSA AES_128_CBC SHA256 TLS_DH_anon_WITH_AES_128_CBC_SHA256 DH_anon AES_128_CBC SHA256 TLS_DH_DSS_WITH_AES_256_CBC_SHA256 DH_DSS AES_256_CBC SHA256 TLS_DH_RSA_WITH_AES_256_CBC_SHA256 DH_RSA AES_256_CBC SHA256 TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 DHE_DSS AES_256_CBC SHA256 TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 DHE_RSA AES_256_CBCSHA256 TLS_DH_anon_WITH_AES_256_CBC_SHA256 DH_anon AES_256_CBC SHA256


鍵IVブロック暗号タイプマテリアルサイズサイズ------------ ------ -------- ---- ----- NULLストリーム0 0 N / A RC4_128ストリーム16 0 N / A 3DES_EDE_CBCブロック24 8 8 AES_128_CBCブロック16 16 16 AES_256_CBCブロック32 16 16 



MACアルゴリズムmac_length mac_key_length -------- ----------- ---------- -------------- NULL N / A 0 0 MD5 HMAC-MD5 16 16 SHA HMAC-SHA1 20 20 SHA256 HMAC-SHA256 32 32 

タイプこれがストリーム暗号であるか、CBCモードで実行されているブロック暗号であるかを示します.  

Key Material書き込みキーの生成に使用されるkey_blockからのバイト数.  

IVサイズ初期化ベクトル用に生成する必要があるデータの量. ストリーム暗号の場合はゼロ. ブロック暗号のブロックサイズと同じです（これはSecurityParameters.record_iv_lengthと同じです）. 

ブロックサイズブロ​​ック暗号が1つのチャンクで暗号化するデータの量. CBCモードで実行されているブロック暗号は、そのブロックサイズの偶数倍しか暗号化できません. 


付録D.実装上の注意 

TLSプロトコルは、多くの一般的なセキュリティミスを防ぐことはできません. このセクションでは、実装者を支援するためのいくつかの推奨事項を示します. 

D.1. 乱数の生成とシード

TLSには、暗号で保護された疑似乱数ジェネレータ（PRNG）が必要です. PRNGの設計とシードには注意が必要です. 安全なハッシュ操作に基づくPRNG、特にSHA-1は許容可能ですが、乱数ジェネレーターの状態のサイズよりも高いセキュリティを提供することはできません. 

生成されるシードマテリアルの量を見積もるには、各シードバイトに予測できない情報のビット数を追加します. たとえば、PC互換の18.2 Hzタイマーから取得したキーストロークタイミング値は、カウンター値の合計サイズが16ビット以上であっても、それぞれ1または2のセキュアビットを提供します. したがって、128ビットのPRNGをシードするには、約100のそのようなタイマー値が必要になります. 

[ランダム]は、ランダムな値の生成に関するガイダンスを提供します.  

D.2. 証明書と認証

実装は証明書の整合性を検証する責任があり、通常は証明書失効メッセージをサポートする必要があります. 信頼できる認証局（CA）による適切な署名を確実にするために、証明書を常に検証する必要があります. 信頼できるCAの選択と追加は、慎重に行う必要があります. ユーザーは、証明書とルートCAに関する情報を表示できる必要があります. 

D.3. 暗号スイート

TLSは、キーサイズとセキュリティレベルの範囲をサポートしています. 適切な実装はおそらく多くの暗号スイートをサポートしません. たとえば、匿名のDiffie-Hellmanは、中間者攻撃を防ぐことができないため、強くお勧めしません. アプリケーションは、最小および最大のキーサイズも適用する必要があります. たとえば、512ビットのRSAキーまたは署名を含む証明書チェーンは、高セキュリティアプリケーションには適していません. 

D.4. 実装の落とし穴

実装の経験から、以前のTLS仕様の特定の部分は理解しにくいことが示され、相互運用性とセキュリティの問題の原因となってきました. これらの領域の多くは

このドキュメントで明確にされていますが、この付録には、実装者から特別な注意を払う必要がある最も重要な事項の短いリストが含まれています.  

TLSプロトコルの問題： 

-複数のTLSレコードに断片化されたハンドシェイクメッセージを正しく処理していますか（セクション6.2.1を参照）？いくつかの小さなフラグメントに分割されるClientHelloのようなコーナーケースを含みますか？最大フラグメントサイズを超えるハンドシェイクメッセージをフラグメント化しますか？特に、証明書と証明書要求のハンドシェイクメッセージは、断片化を必要とするほど大きくなる可能性があります. 

-ServerHelloの前のすべてのTLSレコードのTLSレコードレイヤーバージョン番号を無視しますか（付録E.1を参照）？ 

-拡張フィールドを完全に省略して、ClientHelloでTLS拡張を正しく処理していますか？ 

-クライアントとサーバーの両方が開始した再ネゴシエーションをサポートしていますか？再ネゴシエーションはオプション機能ですが、サポートすることを強くお勧めします. 

-サーバーがクライアント証明書を要求したが、適切な証明書がない場合、メッセージ全体を省略するのではなく、空の証明書メッセージを正しく送信しますか（セクション7.4.6を参照）？ 

暗号化の詳細： 

-RSA暗号化プリマスターシークレットで、バージョン番号を正しく送信して確認しますか？エラーが発生した場合、ブライヒェンバッハー攻撃を回避するためにハンドシェイクを続行しますか（セクション7.4.7.1を参照）？

-RSA復号化および署名操作に対するタイミング攻撃を防ぐためにどのような対策を使用していますか（セクション7.4.7.1を参照）？ 

-RSA署名を検証するときに、NULLパラメータと欠落しているパラメータの両方を受け入れますか（セクション4.7を参照）？RSAパディングにハッシュ値の後に追加のデータがないことを確認しますか？[FI06]

-Diffie-Hellman鍵交換を使用する場合、ネゴシエートされた鍵から先行ゼロバイトを正しく取り除きますか（セクション8.1.2を参照）？ 

-TLSクライアントは、サーバーから送信されたDiffie-Hellmanパラメータが受け入れ可能であることを確認していますか（セクションF.1.1.3を参照）？ 

-CBCモードの暗号で予測できないIVをどのように生成しますか（セクション6.2.3.2を参照）？ 

-長いCBCモードのパディング（最大255バイト. セクション6.2.3.2を参照）を受け入れますか？ 

-CBCモードのタイミング攻撃（セクション6.2.3.2）にどのように対処しますか？ 

-プレマスターシークレット（RSAキー交換用）、Diffie-Hellmanプライベート値、DSA "k"パラメーターなどを生成するために、強力で最も重要な、適切にシードされた乱数ジェネレーター（付録D.1を参照）を使用していますか. セキュリティクリティカルな値？ 

付録E.下位互換性 

E.1. TLS 1.0 / 1.1およびSSL 3.0との互換性

TLSにはさまざまなバージョン（1.0、1.1、1.2、および将来のバージョン）とSSL（2.0および3.0）があるため、使用する特定のプロトコルバージョンをネゴシエートする手段が必要です. TLSプロトコルは、バージョンのネゴシエーションのための組み込みのメカニズムを提供し、他のプロトコルコンポーネントがバージョン選択の複雑さを邪魔しないようにします. 

TLSバージョン1.0、1.1、1.2、およびSSL 3.0は非常によく似ており、互換性のあるClientHelloメッセージを使用します. したがって、それらすべてのサポートは比較的簡単です. 同様に、サーバーは、ClientHello形式の互換性が維持され、クライアントがサーバーで使用可能な最高のプロトコルバージョンをサポートしている限り、TLSの将来のバージョンを使用しようとするクライアントを簡単に処理できます. 

そのような古いサーバーと交渉したいTLS 1.2クライアントは、ClientHello.client_versionに{3、3}（TLS 1.2）を含む通常のTLS 1.2 ClientHelloを送信します. サーバーがこのバージョンをサポートしていない場合、サーバーは古いバージョン番号を含むServerHelloで応答します. クライアントがこのバージョンを使用することに同意すると、ネゴシエーションされたプロトコルに応じて、ネゴシエーションが続行されます. 

サーバーが選択したバージョンがクライアントでサポートされていない（または受け入れられない）場合、クライアントは "protocol_version"警告メッセージを送信して接続を閉じる必要があります.  

TLSサーバーが、サーバーがサポートする最高のバージョンより大きいバージョン番号を含むClientHelloを受信した場合、サーバーがサポートする最高のバージョンに従って応答する必要があります.  

TLSサーバーは、サポートされている最高のバージョンより小さいバージョン番号を含むClientHelloも受信できます. サーバーが古いクライアントとネゴシエートしたい場合は、サーバーがサポートするClientHello.client_version以下の最高バージョンに応じて適切に処理されます. たとえば、サーバーがTLS 1.0、1.1、および1.2をサポートし、client_versionがTLS 1.0である場合、サーバーはTLS 1.0 ServerHelloを続行します. サーバーがclient_versionより大きいバージョンのみをサポートする（または使用する意思がある）場合、「protocol_version」アラートメッセージを送信して接続を閉じる必要があります. 

クライアントがサーバーに認識されている最高のプロトコルバージョンをすでに知っている場合はいつでも（たとえば、セッションを再開するとき）、そのネイティブプロトコルで接続を開始する必要があります（SHOULD）.  

注：一部のサーバー実装では、バージョンネゴシエーションが正しく実装されていないことがわかっています. たとえば、クライアントがTLS 1.0より新しいバージョンを提供すると、接続を閉じるだけのバグのあるTLS 1.0サーバーがあります. また、TLSの拡張機能がClientHelloに含まれている場合、一部のサーバーは接続を拒否することがわかっています. このようなバグのあるサーバーとの相互運用性は、このドキュメントの範囲を超える複雑なトピックであり、クライアントによる複数の接続試行が必要になる場合があります. 

TLS仕様の以前のバージョンでは、ClientHelloを送信するときに（つまり、どのバージョンのプロトコルが使用されるかがわかる前に）レコードレイヤーのバージョン番号（TLSPlaintext.version）に何を含める必要があるかが完全に明確ではありませんでした. したがって、この仕様に準拠するTLSサーバーは、ClientHelloのレコードレイヤーバージョン番号として任意の値{03、XX}を受け入れる必要があります. 

古いサーバーとネゴシエートしたいTLSクライアントは、レコードレイヤーのバージョン番号として任意の値{03、XX}を送信する場合があります. 一般的な値は{03,00}、クライアントがサポートする最小のバージョン番号、ClientHello.client_versionの値です. すべての古いサーバーとの相互運用性を保証する単一の値はありませんが、これはこのドキュメントの範囲を超える複雑なトピックです. 

E.2. SSL 2.0との互換性

SSL 2.0サーバーをサポートしたいTLS 1.2クライアントは、[SSL2]で定義されたバージョン2.0 CLIENT-HELLOメッセージを送信する必要があります. メッセージには、通常のClientHelloに使用されるのと同じバージョン番号が含まれている必要があり、サポートされているTLS暗号スイートをCIPHER-SPECS-DATAフィールドにエンコードする必要があります. 

警告：バージョン2.0のCLIENT-HELLOメッセージを送信する機能は、新しいClientHello形式が新しいバージョンへの移行と拡張機能のネゴシエーションにより優れたメカニズムを提供するため、当然のことながらすべて段階的に廃止されます. TLS 1.2クライアントはSSL 2.0をサポートすべきではありません（SHOULD NOT）. 



ただし、SSL 2.0をサポートしていないTLSサーバーでも、バージョン2.0のCLIENT-HELLOメッセージを受け入れる場合があります. メッセージは、TLSサーバーの実装者向けに以下に詳細に示されています. 真の定義は依然として[SSL2]であると想定されています. 

ネゴシエーションのために、2.0 CLIENT-HELLOは、ClientNelloと同じように解釈され、「null」圧縮方式で拡張されません. このメッセージは、TLSレコードとしてラップされるのではなく、ネットワーク上で直接送信されなければならないことに注意してください. FinishedおよびCertificateVerifyを計算するために、msg_lengthフィールドはハンドシェイクメッセージの一部とは見なされません. 

uint8 V2CipherSpec [3]; struct {uint16 msg_length; uint8 msg_type; バージョンバージョン. uint16 cipher_spec_length; uint16 session_id_length; uint16 challenge_length; V2CipherSpec cipher_specs [V2ClientHello.cipher_spec_length]; 不透明なsession_id [V2ClientHello.session_id_length]; 不透明なチャレンジ[V2ClientHello.challenge_length; } V2ClientHello;

msg_length最上位ビットは1でなければなりません. 残りのビットには、次のデータの長さがバイト単位で含まれています. 

msg_typeこのフィールドは、バージョンフィールドと組み合わせて、バージョン2のClientHelloメッセージを識別します. 値は1でなければなりません. 

version ClientHello.client_versionと同じです.  

cipher_spec_lengthこのフィールドは、フィールドcipher_specsの全長です. ゼロにすることはできず、V2CipherSpecの長さ（3）の倍数にする必要があります. 

session_id_lengthこのフィールドは、TLS 1.2をサポートしていると主張するクライアントに対してはゼロの値を持つ必要があります.  

challenge_length自身を認証するためのサーバーへのクライアントのチャレンジの長さ（バイト単位）. これまで、許容される値は16〜32バイトです. SSLv2下位互換ハンドシェイクを使用する場合、クライアントは32バイトのチャレンジを使用する必要があります（SHOULD）. 

cipher_specsこれは、クライアントが喜んで使用できるすべてのCipherSpecのリストです. [SSL2]で定義された2.0暗号仕様に加えて、これには通常ClientHello.cipher_suitesで送信されるTLS暗号スイートが含まれ、各暗号スイートには0バイトがプレフィックスとして付加されます. たとえば、TLS暗号スイート{0x00,0x0A}は{0x00,0x00,0x0A}として送信されます. 

session_idこのフィールドは空でなければなりません.  

challenge ClientHello.randomに対応します. チャレンジの長さが32未満の場合、TLSサーバーはデータを先行（注：後続ではない）ゼロバイトで埋めて32バイト長にします. 

注：TLSセッションを再開する要求は、TLSクライアントのHelloを使用する必要があります.  

E.3. 中間者バージョンのロールバックの回避

TLSクライアントがバージョン2.0互換モードにフォールバックする場合、クライアントは特別なPKCS＃1ブロックフォーマットを使用する必要があります. これは、TLSサーバーがTLS対応クライアントとのバージョン2.0セッションを拒否するように行われます. 

クライアントがSSL 2.0をネゴシエートするがTLSもサポートする場合、ENCRYPTED-KEY-のRSA暗号化のために、PKCSパディングの右側（最下位）8ランダムバイト（パディングの端末ヌルを含まない）を設定する必要がありますCLIENT-MASTER-KEYのDATAフィールドを0x03に変更します（他のパディングバイトはランダムです）.  

TLS対応サーバーがSSL 2.0をネゴシエートする場合は、SHOULD、ENCRYPTED-KEY-DATAフィールドを復号化した後、これらの8つのパディングバイトが0x03であることを確認します. そうでない場合、サーバーはSECRET-KEY-DATAのランダムな値を生成し、ハンドシェイクを続行する必要があります（キーが一致しないため、最終的に失敗します）. エラー状況をクライアントに報告すると、サーバーが[BLEI]で説明されている攻撃に対して脆弱になる可能性があることに注意してください. 

付録F.セキュリティ分析 

TLSプロトコルは、安全でないチャネルを介して通信するクライアントとサーバー間の安全な接続を確立するように設計されています. このドキュメントは、攻撃者がかなりの計算リソースを持ち、プロトコル外のソースから秘密情報を取得できないことを含め、いくつかの従来の仮定を行います. 攻撃者は、通信チャネルを介して送信されたメッセージをキャプチャ、変更、削除、再生、その他改ざんする機能を持っていると想定されています. この付録では、さまざまな攻撃に対抗するためにTLSがどのように設計されているかについて概説します. 

F.1. ハンドシェイクプロトコル

ハンドシェイクプロトコルは、暗号仕様の選択とマスターシークレットの生成を担当します. マスターシークレットは、安全なセッションに関連付けられたプライマリ暗号化パラメーターをまとめて構成します. ハンドシェイクプロトコルは、信頼できる認証局によって署名された証明書を持つ当事者をオプションで認証することもできます. 

F.1.1. 認証と鍵交換

TLSは3つの認証モードをサポートします. 両方の認証、非認証クライアントによるサーバー認証、完全な匿名性です. サーバーが認証されるときはいつでも、チャネルは中間者攻撃に対して安全ですが、完全に匿名のセッションは本質的にそのような攻撃に対して脆弱です. 匿名サーバーはクライアントを認証できません. サーバーが認証される場合、その証明書メッセージは、受け入れ可能な認証局につながる有効な証明書チェーンを提供する必要があります. 同様に、認証されたクライアントは、受け入れ可能な証明書をサーバーに提供する必要があります. 各当事者は、相手の証明書が有効であり、有効期限が切れていない、または取り消されていないことを確認する責任があります. 

鍵交換プロセスの一般的な目標は、攻撃者ではなく通信相手に知られるpre_master_secretを作成することです. pre_master_secretは、master_secretを生成するために使用されます（セクション8.1を参照）. 完成したメッセージ、暗号化キー、およびMACキーを生成するには、master_secretが必要です（セクション7.4.9および6.3を参照）. したがって、パーティは正しいFinishedメッセージを送信することにより、正しいpre_master_secretを知っていることを証明します. 

F.1.1.1. 匿名キー交換

キーの交換にDiffie-Hellmanを使用すると、完全に匿名のセッションを確立できます. サーバーの公開パラメーターはサーバーの鍵交換メッセージに含まれ、クライアントの公開パラメーターは

クライアント鍵交換メッセージ. プライベートな値を知らない盗聴者は、Diffie-Hellmanの結果（つまり、pre_master_secret）を見つけることができません. 

警告：完全に匿名の接続は、受動的な盗聴に対する保護のみを提供します. 独立した改ざん防止チャネルを使用して、完了メッセージが攻撃者に置き換えられていないことを確認しない限り、アクティブな中間者攻撃が懸念される環境ではサーバー認証が必要です. 

F.1.1.2. RSAキー交換と認証

RSAでは、鍵交換とサーバー認証が組み合わされています. 公開鍵はサーバーの証明書に含まれています. サーバーの静的RSAキーが侵害されると、その静的キーで保護されているすべてのセッションの機密性が失われることに注意してください. Perfect Forward Secrecyを希望するTLSユーザーは、DHE暗号スイートを使用する必要があります. 秘密鍵の公開による被害は、秘密鍵（および証明書）を頻繁に変更することで制限できます. 

サーバーの証明書を検証した後、クライアントはサーバーの公開鍵を使用してpre_master_secretを暗号化します. pre_master_secretを正常にデコードして正しいFinishedメッセージを生成することにより、サーバーは、サーバー証明書に対応する秘密鍵を知っていることを示します. 

RSAをキー交換に使用する場合、クライアントは証明書検証メッセージを使用して認証されます（セクション7.4.8を参照）. クライアントは、先行するすべてのハンドシェイクメッセージから派生した値に署名します. これらのハンドシェイクメッセージには、署名をサーバーにバインドするサーバー証明書と、署名を現在のハンドシェイクプロセスにバインドするServerHello.randomが含まれます. 

F.1.1.3. 認証付きのDiffie-Hellman鍵交換

Diffie-Hellman鍵交換が使用される場合、サーバーは、固定Diffie-Hellmanパラメーターを含む証明書を提供するか、サーバー鍵交換メッセージを使用して、DSAまたはRSA証明書で署名された一時的なDiffie-Hellmanパラメーターのセットを送信できます. 一時的なパラメータは、署名前にhello.random値でハッシュされ、攻撃者が古いパラメータを再生しないようにします. どちらの場合も、クライアントは証明書または署名を検証して、パラメーターがサーバーに属していることを確認できます. 

クライアントに固定Diffie-Hellmanパラメーターを含む証明書がある場合、その証明書には、鍵交換を完了するために必要な情報が含まれています. この場合、クライアントとサーバーは、通信するたびに同じDiffie-Hellman結果（つまり、pre_master_secret）を生成することに注意してください. pre_master_secretが必要以上に長くメモリにとどまらないようにするには、できるだけ早くmaster_secretに変換する必要があります. 鍵交換が機能するためには、クライアントのDiffie-Hellmanパラメーターがサーバーから提供されたパラメーターと互換性がある必要があります. 

クライアントが標準のDSAまたはRSA証明書を持っているか、認証されていない場合、クライアントはクライアントの鍵交換メッセージで一時パラメーターのセットをサーバーに送信し、オプションで証明書検証メッセージを使用して自身を認証します.  

同じDHキーペアを複数のハンドシェイクに使用する場合、クライアントまたはサーバーに固定DHキーペアを含む証明書があるか、サーバーがDHキーを再利用しているため、小さなサブグループ攻撃を防ぐように注意する必要があります. 実装は、[サブグループ]にあるガイドラインに従う必要があります. 

小さなサブグループ攻撃は、DHE暗号スイートの1つを使用し、ハンドシェイクごとに新しいDH秘密キー（X）を生成することで最も簡単に回避できます. 適切なベース（2など）を選択すると、g ^ X mod pを非常に迅速に計算できます. したがって、パフォーマンスコストは最小限に抑えられます. さらに、ハンドシェイクごとに新しいキーを使用すると、Perfect Forward Secrecyが提供されます. 実装は、DHE暗号スイートを使用する場合、ハンドシェイクごとに新しいXを生成する必要があります（SHOULD）. 

TLSではサーバーが任意のDHグループを提供できるため、クライアントはDHグループがローカルポリシーで定義されている適切なサイズであることを確認する必要があります. クライアントは、DH公開指数が適切なサイズであるように見えることも確認する必要があります. [KEYSIZ]は、さまざまなグループサイズの強さを示す便利なガイドです. サーバーは、[IKEALG]や[MODP]で定義されているような既知のグループを提供することで、クライアントを支援することを選択できます（MAY）. これらは簡単な比較で確認できます. 

F.1.2. バージョンロールバック攻撃

TLSにはSSLバージョン2.0に対する大幅な改善が含まれているため、攻撃者はTLS対応のクライアントとサーバーをバージョン2.0にフォールバックしようとする可能性があります. この攻撃は、2つのTLS対応パーティがSSL 2.0ハンドシェイクを使用している場合にのみ発生します. 

非ランダムPKCS＃1ブロックタイプ2メッセージパディングを使用するソリューションは洗練されていませんが、バージョン3.0サーバーが攻撃を検出するためのかなり安全な方法を提供します. このソリューションは、アプリケーションが指定した待機しきい値が満了する前に、キーをブルートフォースし、同じキーを含む新しいENCRYPTED-KEY-DATAメッセージを（ただし、通常のパディングを使用して）置き換える攻撃者に対して安全ではありません. PKCSパディングの最下位8バイトのパディングを変更しても、プロトコルで使用される署名付きハッシュのサイズとRSAキーの長さのセキュリティには影響しません. これは、入力ブロックサイズを8バイト増やすことと本質的に同じであるためです. 

F.1.3. ハンドシェイクプロトコルに対する攻撃の検出

攻撃者は、当事者が通常よりも異なる暗号化アルゴリズムを選択するように、ハンドシェイク交換に影響を与えようとする可能性があります.  

この攻撃では、攻撃者は1つ以上のハンドシェイクメッセージを積極的に変更する必要があります. これが発生した場合、クライアントとサーバーは、ハンドシェイクメッセージハッシュの異なる値を計算します. その結果、当事者はお互いの完了メッセージを受け入れません. master_secretがないと、攻撃者は完了メッセージを修復できないため、攻撃が発見されます. 

F.1.4. セッションの再開

セッションを再開して接続が確立されると、新しいClientHello.randomとServerHello.randomの値がセッションのmaster_secretでハッシュされます. master_secretが危険にさらされておらず、暗号化キーとMACキーの生成に使用される安全なハッシュ操作が安全であれば、接続は安全で、以前の接続から事実上独立している必要があります. 攻撃者は、既知の暗号化キーやMACシークレットを使用して、安全なハッシュ操作を壊さずにmaster_secretを侵害することはできません. 

クライアントとサーバーの両方が同意しない限り、セッションを再開することはできません. どちらかの当事者が、セッションが危険にさらされている可能性がある、または証明書の有効期限が切れているか取り消されている可能性があると疑う場合は、完全なハンドシェイクを強制する必要があります. master_secretを取得する攻撃者は、対応するセッションIDが廃止されるまで、侵害されたパーティを偽装できる可能性があるため、セッションIDのライフタイムには24時間の上限をお勧めします. 比較的安全性の低い環境で実行される可能性のあるアプリケーションは、安定したストレージにセッションIDを書き込まないでください. 

F.2. アプリケーションデータの保護

master_secretはClientHello.randomおよびServerHello.randomでハッシュされ、接続ごとに一意のデータ暗号化キーとMACシークレットが生成されます.  

送信データは、送信前にMACで保護されます. メッセージの再生または変更攻撃を防ぐために、MACはMACキー、シーケンス番号、メッセージの長さ、メッセージの内容、および2つの固定文字列から計算されます. メッセージタイプフィールドは、あるTLSレコードレイヤクライアント宛のメッセージが別のクライアントにリダイレクトされないようにするために必要です. シーケンス番号により、メッセージの削除または並べ替えの試行が確実に検出されます. シーケンス番号は64ビット長であるため、オーバーフローすることはありません. あるパーティからのメッセージは、独立したMACキーを使用するため、他のパーティの出力に挿入できません. 同様に、サーバー書き込みキーとクライアント書き込みキーは独立しているため、ストリーム暗号キーは1回だけ使用されます. 

攻撃者が暗号化キーを破った場合、それを使用して暗号化されたすべてのメッセージを読み取ることができます. 同様に、MACキーが侵害されると、メッセージ変更攻撃が可能になります. MACも暗号化されているため、メッセージ変更攻撃では、通常、MACだけでなく暗号化アルゴリズムも破る必要があります. 

注：MACキーは暗号化キーよりも大きい場合があるため、暗号化キーが壊れていてもメッセージは改ざんされないままでいる可能性があります.  

F.3. 明示的なIV

[CBCATT]は、レコードのIVを知っていることに依存する、TLSに対する選択された平文攻撃について説明しています. 以前のバージョンのTLS [TLS1.0]は、以前のレコードのCBC残差をIVとして使用していたため、この攻撃が可能でした. このバージョンでは、この攻撃から保護するために明示的なIVを使用しています. 

F.4. 複合暗号モードのセキュリティ

TLSは、ネゴシエートされた暗号スイートで定義された対称暗号化および認証機能を使用して、送信されたアプリケーションデータを保護します. 目的は、ネットワーク内のアクティブな攻撃者による悪意のあるアクションから送信データの整合性と機密性の両方を保護することです. 暗号化および認証機能がデータに適用される順序が、この目標を達成するために重要な役割を果たすことがわかります[ENCAUTH]. 

暗号化してから認証と呼ばれる最も堅牢な方法は、最初にデータに暗号化を適用し、次に暗号文にMACを適用します. この方法は、暗号化とMAC機能の任意のペアで整合性と機密性の目標が確実に得られることを保証します. TLSは、authenticate-then-encryptと呼ばれる別の方法を使用します. この方法では、最初に平文でMACが計算され、次に平文とMACの連結が暗号化されます. この方法は、暗号化機能とMAC機能のCERTAINの組み合わせに対して安全であることが証明されていますが、一般的に安全であるとは限りません. 特に、安全なMAC機能と組み合わせると、完全な安全な暗号化機能（情報理論的にも安全）が存在し、アクティブな攻撃に対する機密性の目標を達成できないことが示されています. したがって、TLSに採用された新しい暗号スイートと操作モードは、認証後暗号化方式で分析して、指定された整合性と機密性の目標を達成していることを確認する必要があります. 

現在、authenticate-then-encryptメソッドのセキュリティは、いくつかの重要なケースで証明されています. 1つはストリーム暗号の場合で、メッセージの長さとMACタグの長さの計算上予測不可能なパッドが疑似ランダムジェネレーターを使用して生成され、このパッドはプレーンテキストとMACタグの連結と排他的論理和がとられます. もう1つは、安全なブロック暗号を使用するCBCモードの場合です. この場合、プレーンテキストとMACの連結に1つのCBC暗号化パスを適用し、プレーンテキストとMACの新しいペアごとに新しい独立した予測不可能なIVを使用すると、セキュリティが示されます. 1.1より前のバージョンのTLSでは、CBCモードは、前の暗号文の最後のブロックの形式で予測可能なIVを使用することを除いて、適切に使用されていました. これにより、選択したプレーンテキスト攻撃に対してTLSが開かれました. このバージョンのプロトコルは、これらの攻撃の影響を受けません. 安全であることが証明された暗号化モードの詳細については、[ENCAUTH]を参照してください. 

F.5. サービス拒否

TLSは、多くのサービス拒否（DoS）攻撃の影響を受けます. 特に、多数のTCP接続を開始する攻撃者は、RSA復号化を実行するためにサーバーに大量のCPUを消費させる可能性があります. ただし、TLSは一般にTCP上で使用されるため、TCPスタックが適切なTCP SYNランダム化[SEQNUM]を使用している場合、攻撃者が攻撃元を隠すのは困難です. 

TLSはTCPを介して実行されるため、個々の接続で多数のDoS攻撃を受けやすくなります. 特に、攻撃者はRSTを偽造して接続を終了するか、部分的なTLSレコードを偽造して接続を停止させる可能性があります. これらの攻撃は、一般に、TCPを使用するプロトコルでは防御できません. このクラスの攻撃に関心のある実装者またはユーザーは、IPsec AH [AH]またはESP [ESP]を使用する必要があります. 

F.6. 最終メモ

TLSが安全な接続を提供できるようにするには、クライアントとサーバーの両方のシステム、キー、およびアプリケーションが安全である必要があります. さらに、実装にはセキュリティエラーがないことが必要です. 



システムは、サポートされている最も弱い鍵交換と認証アルゴリズムと同じくらい強力であり、信頼できる暗号化機能のみを使用する必要があります. 短い公開鍵と匿名サーバーは慎重に使用する必要があります. 実装とユーザーは、どの証明書と認証局が許容できるかを決定するときに注意する必要があります. 不正な認証局は多大な損害を与える可能性があります. 

規範的な参考文献 

[AES]米国国立標準技術研究所、「Advanced Encryption Standard（AES）の仕様」FIPS197. 2001年11月26日.  

[3DES] National Institute of Standards and Technology、「Recommendation for the Triple Data Encryption Algorithm（TDEA）Block Cipher」、NIST Special Publication 800-67、2004年5月.  

[DSS] NIST FIPS PUB 186-2、「デジタル署名標準」、米国連邦情報・技術研究所、米国商務省、2000年.  

[HMAC] Krawczyk、H.、Bellare、M. 、およびR. Canetti、「HMAC：Keyed- Hashing for Message Authentication」、RFC 2104、1997年2月.  

[MD5] Rivest、R. 、「MD5メッセージダイジェストアルゴリズム」、RFC 1321、1992年4月.  

[PKCS1] Jonsson、J. およびB. Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA Cryptography Specifications Version 2.1」、RFC 3447、2003年2月.  

[PKIX] Housley、R.、Polk、W.、Ford、W. 、およびD. Solo、「Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List（CRL）Profile」、RFC 3280、2002年4月.  

[SCH] B.シュナイアー. 「Applied Cryptography：Protocols、Algorithms、and Source Code in C、2nd ed. 」、John Wiley＆Sons、Inc. 1996年発行. 

[SHS] NIST FIPS PUB 180-2、「Secure Hash Standard」、国立標準技術研究所、米国商務省、2002年8月.  



[REQ] Bradner、S. 、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月.  

[RFC2434] Narten、T. およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 2434、1998年10月.  

[X680] ITU-T勧告X.680（2002）| ISO / IEC 8824-1：2002、情報技術-抽象構文記法1（ASN.1）：基本記法の仕様. 

[X690] ITU-T勧告X.690（2002）| ISO / IEC 8825-1：2002、情報技術-ASN.1エンコーディングルール：基本エンコーディングルール（BER）、正規エンコーディングルール（CER）、および識別エンコーディングルール（DER）の仕様. 

参考情報 

[AEAD] McGrew、D. 、「認証された暗号化のためのインターフェースとアルゴリズム」、RFC 5116、2008年1月.  

[AH]ケント、S. 、「IP認証ヘッダー」、RFC 4302、2005年12月.  

[BLEI] Bleichenbacher D. 、「Advance in Cryptology-CRYPTO'98、LNCS vol. 」の「RSA Encryption Standard PKCS＃1に基づくプロトコルに対する選択された暗号文攻撃」1462、ページ：1-12、1998. 

[CBCATT] Moeller、B. 、「SSL / TLSにおけるCBC暗号スイートのセキュリティ：問題と対策」、http：//www.openssl.org/~bodo/tls-cbc.txt.  

[CBCTIME] Canvel、B.、Hiltgen、A.、Vaudenay、S. 、およびM. Vuagnoux、「SSL / TLSチャネルでのパスワード傍受」、Cryptologyの進歩-CRYPTO 2003、LNCS vol. 2729、2003. 

[CCM]「NIST Special Publication 800-38C：CCM Mode for Authentication and Confidentiality」、http：//csrc.nist.gov/publications/nistpubs/800-38C/ SP800-38C.pdf 

[DES] National Institute of Standards and Technology、「Data Encryption Standard（DES）」、FIPS PUB 46-3、1999年10月.  





[DSS-3] NIST FIPS PUB 186-3ドラフト、「デジタル署名標準」、米国連邦情報・技術研究所、米国商務省、2006年.  

[ECDSA] American National Standards Institute、「金融サービス業界の公開鍵暗号化：楕円曲線デジタル署名アルゴリズム（ECDSA）」、ANS X9.62-2005、2005年11月.  

[ENCAUTH] Krawczyk、H. 、「通信を保護するための暗号化と認証の順序（または、SSLの安全性は？）」、Crypto 2001.  

[ESP]ケント、S. 、「IPカプセル化セキュリティペイロード（ESP）」、RFC 4303、2005年12月.  

[FI06] Hal Finney、「実装エラーに基づくブライチェンバッハーのRSA署名偽造」、ietf-openpgp @ imc.orgメーリングリスト、2006年8月27日、http：//www.imc.org/ietf-openpgp/ mail-archive / msg14307 .html.  

[GCM] Dworkin、M.、NIST Special Publication 800-38D、「Recommendation for Block Cipher Modes of Operation：Galois / Counter Mode（GCM）and GMAC」、2007年11月.  

[IKEALG] Schiller、J. 、「インターネットキーエクスチェンジバージョン2（IKEv2）で使用する暗号化アルゴリズム」、RFC 4307、2005年12月.  

[KEYSIZ]オーマン、H. 、およびP.ホフマン、「対称鍵の交換に使用される公開鍵の強度の決定」、BCP 86、RFC 3766、2004年4月.  

[KPR03] Klima、V.、Pokorny、O.、Rosa、T. 、「SSL / TLSでのRSAベースのセッションへの攻撃」、http：//eprint.iacr.org/2003/052/、2003年3月.  

[MODP] Kivinen、T. 、およびM. Kojo、「インターネット鍵交換（IKE）のためのより多くのモジュラー指数（MODP）Diffie-Hellmanグループ」、RFC 3526、2003年5月.  

[PKCS6] RSA Laboratories、「PKCS＃6：RSA Extended Certificate Syntax Standard」、バージョン1.5、1993年11月.  

[PKCS7] RSA Laboratories、「PKCS＃7：RSA Cryptographic Message Syntax Standard」、バージョン1.5、1993年11月.  



[ランダム] Eastlake、D.、3rd、Schiller、J. 、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月.  

[RFC3749] Hollenbeck、S. 、「Transport Layer Security Protocol Compression Methods」、RFC 3749、2004年5月.  

[RFC4366] Blake-Wilson、S.、Nystrom、M.、Hopwood、D.、Mikkelsen、J. 、およびT. Wright、「Transport Layer Security（TLS）Extensions」、RFC 4366、2006年4月.  

[RSA] R.リベスト、A. シャミル、およびLMアドルマン、「デジタル署名と公開鍵暗号システムを取得する方法」、ACMの通信、v. 21、n. 1978年2月2日、120-126ページ. 

[SEQNUM] Bellovin、S.、「シーケンス番号攻撃に対する防御」、RFC 1948、1996年5月.  

[SSL2] Hickman、Kipp、「SSLプロトコル」、Netscape Communications Corp.、1995年2月9日.  

[SSL3] A. Freier、P. Karlton、およびP. Kocher、「SSL 3.0プロトコル」、Netscape Communications Corp.、1996年11月18日.  

[サブグループ] Zuccherato、R. 、「S / MIMEのDiffie-Hellman鍵合意方法に対する「小サブグループ」攻撃を回避する方法」、RFC 2785、2000年3月.  

[TCP] Postel、J. 、「Transmission Control Protocol」、STD 7、RFC 793、1981年9月.  

[タイミング] Boneh、D.、Brumley、D. 、「リモートタイミング攻撃は実用的」、USENIXセキュリティシンポジウム2003.  

[TLSAES] Chown、P. 、「Advanced Encryption Standard（AES）Ciphersuites for Transport Layer Security（TLS）」、RFC 3268、2002年6月.  

[TLSECC] Blake-Wilson、S.、Bolyard、N.、Gupta、V.、Hawk、C. 、およびB. Moeller、「Elliptic Curve Cryptography（ECC）Cipher Suites for Transport Layer Security（TLS）」、RFC 4492 、2006年5月.  

[TLSEXT] Eastlake、D.、3番目、「Transport Layer Security（TLS）Extensions：Extension Definitions」、Work in Progress、2008年2月.  



[TLSPGP] Mavrogiannopoulos、N. 、「Using OpenPGP Keys for Transport Layer Security（TLS）Authentication」、RFC 5081、2007年11月.  

[TLSPSK] Eronen、P.、Ed. およびH. Tschofenig、Ed. 、 "Pre-Shared Key Ciphersuites for Transport Layer Security（TLS）"、RFC 4279、December 2005.  

[TLS1.0] Dierks、T. およびC. Allen、「The TLS Protocol Version 1.0」、RFC 2246、1999年1月.  

[TLS1.1] Dierks、T. およびE. Rescorla、「The Transport Layer Security（TLS）Protocol Version 1.1」、RFC 4346、2006年4月.  

[X501] ITU-T勧告X.501：情報技術-オープンシステム相互接続-ディレクトリ：モデル、1993.  

[XDR] Eisler、M. 、編、「XDR：外部データ表現標準」、STD 67、RFC 4506、2006年5月.  

ワーキンググループ情報 

IETF TLSワーキンググループのディスカッションリストは、電子メールアドレス<tls@ietf.org>にあります. グループに関する情報とリストの購読方法に関する情報は、<https://www1.ietf.org/mailman/listinfo/tls>にあります. 

リストのアーカイブは、<http://www.ietf.org/mail-archive/web/tls/current/index.html>にあります.  

貢献者 

Christopher Allen（TLS 1.0の共同編集者）Alacrity Ventures ChristopherA@AlacrityManagement.com 

カリフォルニア州マーティンアバディ大学、サンタクルーズabadi@cs.ucsc.edu 

スティーブンM.ベロビンコロンビア大学smb@cs.columbia.edu 

Simon Blake-Wilson BCI sblakewilson@bcisse.com 

Ran Canetti IBM canetti@watson.ibm.com 

Pete Chown Skygate Technology Ltd pc@skygate.co.uk 

Taher Elgamal taher@s​​ecurify.com Securify 

Pasi Eronen pasi.eronen@nokia.comノキア 

Anil Gangolli anil@busybuddha.org 

キップ・ヒックマン 

アルフレッド・ホーネス 

デビッド・ホップウッド独立コンサルタントdavid.hopwood@blueyonder.co.uk 

Phil Karlton（SSLv3の共著者） 

Paul Kocher（SSLv3の共著者）Cryptography Research paul@cryptography.com 

Hugo Krawczyk IBM hugo@ee.technion.ac.il 

Jan Mikkelsenトランザクションウェアjanm@transactionware.com 

Magnus Nystrom RSAセキュリティmagnus@rsasecurity.com 

Robert Relyea Netscape Communications relyea@netscape.com Jim Roskind Netscape Communications jar@netscape.com 

マイケル・サビン 

Dan Simon Microsoft、Inc. dansimon@microsoft.com 

トム・ワインスタイン 

ティムライトボーダフォンtimothy.wright@vodafone.com 

編集者のアドレス 

Tim Dierks独立メール：tim@dierks.org 

Eric Rescorla RTFM、Inc.メール：ekr@rtfm.com 

完全な著作権表示 

Copyright（C）The IETF Trust（2008）.  

このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、ここに記載されている場合を除き、著者はすべての権利を保持します.  

このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代理人または組織は（もしあれば）、インターネット社会、IETFトラスト、およびインターネットエンジニアリングタスクフォースを否認します. 明示または黙示を問わず、ここに含まれる情報の使用が商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害しないことを保証するものではありません.  

知的財産 

IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるまたは適用されない範囲に関して、いかなる立場も取らない. 利用できる; また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません. RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります. 

IETF事務局に対して行われたIPR開示のコピー、およびライセンスが利用可能になることの保証、またはこの仕様の実装者またはユーザーによる一般ライセンスまたはそのような所有権の使用の許可を得ようとした試みの結果を取得できます.  http://www.ietf.org/iprのIETFオンラインIPRリポジトリから.  

IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけます. IEETのietf-ipr@ietf.orgに情報を送信してください. 
